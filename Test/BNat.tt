-- An example of bounded natural numbers using proofs with the Leibniz equality
--
-- We work towards a bounded natural number (BNat) whose upper limit is encoded in its type.
-- (Similar to `Fin`)
--
-- Addition of two BNats requires a proof that (S n) + m === n + (S m)

import Data.Nat
import Proofs

-- Bounded Nats
data BNat : Nat -> Type where
    BZ : {r : Nat} -> BNat r
    BS : {r : Nat} -> BNat r -> BNat (S r)

-- Conversion from Nat to minimal BNat
natToBNat : (x : Nat) -> BNat x
natToBNat Z = BZ {Z}
pat n : Nat =>
  natToBNat (S n) = BS {n} (natToBNat n)

-- Take our equality from plusSuccRightSucc and convert it to a type-coersion style function
-- via eqInd2. We'll need this for our BNat example.
lemmaSRS : {n : Nat} -> {m : Nat} -> -- And two Nats, n & m
           BNat (plus (S n) m)       -> -- If the property holds for Sn + m
           BNat (plus n (S m))          -- We prove that it holds for n + Sm
pat n, m : Nat, val : BNat (plus (S n) m) =>
  lemmaSRS {n} {m} val
    = eqInd2 {Nat} {plus (S n) m} {plus n (S m)}
             {plusSuccRightSucc n m} {BNat} val

-- Additions of two BNats, preserving their bounds.
-- This relies on our proof of plusSComm
plusB : {r1 : Nat} -> {r2 : Nat} ->
        BNat r1    -> BNat r2 ->
        BNat (plus r1 r2)

pat r1 : Nat, r2 : Nat =>
  plusB {r1} {r2} (BZ {r1}) (BZ {r2})
    = BZ {plus r1 r2}

pat r1 : Nat, r2 : Nat, y : BNat r2 =>
  plusB {r1} {S r2} (BZ {r1}) (BS {r2} y)
    = let rec : BNat (S (plus r1 r2))
              = BS {plus r1 r2} (plusB {r1} {r2} (BZ {r1}) y)
      in lemmaSRS {r1} {r2} rec

pat r1 : Nat, r2 : Nat, x : BNat r1, y : BNat r2 =>
  plusB {S r1} {r2} (BS {r1} x) y
    = BS {plus r1 r2} (plusB {r1} {r2} x y)

-- Examples at REPL:
-- > plusB {3} {2} (BS {2} (BZ {2})) (natToBNat 2)