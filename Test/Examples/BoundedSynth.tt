import Data.Nat
import Data.Nat.Half
import Data.Fin
import Data.Vect

-- Introducing Bits --------------------------------------------------
----------------------------------------------------------------------

simple Bit : Type where
  O : Bit
  I : Bit

simple Pair : Type -> Type -> Type where
     MkP : {a,b : Type} -> a -> b -> Pair a b

-- Full adder
addBit : Bit -> Bit -> Bit -> Pair Bit Bit
addBit O O O = MkP {_} {_} O O
addBit O O I = MkP {_} {_} O I
addBit O I O = MkP {_} {_} O I
addBit O I I = MkP {_} {_} I O
addBit I O O = MkP {_} {_} O I
addBit I O I = MkP {_} {_} I O
addBit I I O = MkP {_} {_} I O
addBit I I I = MkP {_} {_} I I

-- Binary numbers indexed by width -----------------------------------
----------------------------------------------------------------------

simple Bin : Nat -> Type where
  BinNil : Bin 0
  BinCons : {n : Nat} -> Bin n -> Bit -> Bin (S n)

zeroBin : (n : Nat) -> < Bin n >
zeroBin Z = [| BinNil |]
pat n =>
  zeroBin (S n) = [| BinCons {_} ~(zeroBin n) O |]

addBin' : (n : Nat) -> < Bin n > -> < Bin n > -> < Bit > -> < Bin (S n) >
pat cin =>
  addBin' Z [| BinNil |] [| BinNil |] cin
    = [| BinCons {_} BinNil ~cin |]
pat n, x, xs, y, ys, cin =>
  addBin' (S n) [| BinCons {_} xs x |] [| BinCons {_} ys y |] cin
    = [| case addBit ~cin x y of
           pat cin', lsb =>
             MkP {_} {_} cin' lsb ==>
               BinCons {_} ~(addBin' _ [|xs|] [|ys|] [|cin'|]) lsb
      |]

bx : Bin 3
bx = BinCons {_} (BinCons {_} (BinCons {_} BinNil O) I) I

by : Bin 2
by = BinCons {_} (BinCons {_} BinNil I) O

resizeBin : (n, n' : Nat) -> < Bin n > -> < Bin n' >
-- Extend with zeros
pat n' =>
  resizeBin Z n' [| BinNil |] = zeroBin n'
-- Truncate
pat n, bs =>
  resizeBin n Z bs = [| BinNil |] 
-- Recurse
pat n, n', bs, b =>
  resizeBin (S n) (S n') [| BinCons {_} bs b |]
    = [| BinCons {_} ~(resizeBin n n' [|bs|]) b |]

addBin : (n, m : Nat) -> < Bin n > -> < Bin m > -> < Bit > -> < Bin (S (max n m)) >
pat n, m, xs, ys, cin =>
  addBin n m xs ys cin = addBin' (max n m) (resizeBin n (max n m) xs)
                                           (resizeBin m (max n m) ys) cin

mulConstBin : (n : Nat) -> {c : Nat} -> (chr : HalfRec c) ->
            < Bin n > -> < Bin (plus (clog2 c) n) >
pat c, chr =>
  mulConstBin Z {c} chr [| BinNil |] = zeroBin _
pat n, xs =>
  mulConstBin n {Z} HalfRecZ xs = zeroBin _
pat n, xs =>
  mulConstBin n {1} HalfRec1 xs = resizeBin _ _ xs
pat n, c, chr, xs =>
  mulConstBin n {plus (S c) (S c)} (HalfRecEven c chr) xs
    = resizeBin _ _ [|BinCons {_} ~(mulConstBin n {S c} chr xs) O|]
pat n, c, chr, xs =>
  mulConstBin n {S (plus (S c) (S c))} (HalfRecOdd c chr) xs
    = resizeBin _ _ (addBin _ _ [| BinCons {_} ~(mulConstBin n {S c} chr xs) O |] xs [|O|])

gateBin : (n : Nat) -> <Bit> -> <Bin n> -> <Bin n>
pat b =>
  gateBin Z [|b|] [|BinNil|] = [|BinNil|]
pat n, b, xs, x =>
  gateBin (S n) b [|BinCons {_} xs x|]
    = [| case ~b of
           O ==> BinCons {_} ~(gateBin _ [|O|] [|xs|]) O
           I ==> BinCons {_} ~(gateBin _ [|I|] [|xs|]) x
      |]

mulBin : (n, m : Nat) -> < Bin n > -> < Bin m > -> < Bin (plus n m) >
pat m, ys =>
  mulBin Z m [| BinNil |] ys = zeroBin _
pat n, m, xs, x, ys =>
  mulBin (S n) m [| BinCons {_} xs x |] ys
    = [| let row = ~(gateBin _ [|x|] ys)
             rec = ~(mulBin _ _ [|xs|] [|BinCons {_} ~ys O|])
             ans = ~(addBin _ _ [|row|] [|rec|] [|O|])
         in ~(resizeBin _ _ [|ans|])
      |]

{- little synthesisable multiplier
mymul : < Bin 4 -> Bin 3 -> Bin (plus 4 3) >
mymul = [| \x => \y => ~(mulBin 4 3 [|x|] [|y|]) |]
-}


-- Binary numbers indexed by their upper bound -----------------------
----------------------------------------------------------------------

simple Bounded : Nat -> Type where
  MkB : {n, w : Nat} -> {prf : Equal Nat w (clog2 (S n))} -> Bin w -> Bounded n

-- Bit funny, but Bounded will actually error if we try to construct one with a
-- binary number with _more_ bits than we need (as well as less)!

boundedToBin : (n : Nat) -> Bounded n -> Bin (clog2 (S n))
pat n, w, prf, xs =>
  boundedToBin n (MkB {n} {w} {prf} xs) = eqInd2 {_} {_} {_} {prf} {\h => Bin h} xs

addB : (n, m : Nat) -> < Bounded n > -> < Bounded m > -> < Bounded (plus n m) >
pat n, nw, prfn, m, mw, prfm, xs, ys =>
  addB n m [| MkB {n} {nw} {prfn} xs |] [| MkB {m} {mw} {prfm} ys |]
    = [| let ans = ~(resizeBin _ (clog2 (S (plus n m))) (addBin _ _ [|xs|] [|ys|] [|O|]))
         in MkB {_} {_} {Refl {_} {_}} ans
      |]

mulConstB : (n : Nat) -> (c : Nat) ->
            < Bounded n > -> < Bounded (mul c n) >
pat n, nw, prfn, c, xs =>
  mulConstB n c [| MkB {n} {nw} {prfn} xs |]
    = [| MkB {_} {_} {Refl {_} {_}} ~(resizeBin _ (clog2 (S (mul c n))) (mulConstBin _ {c} (halfRec c) [|xs|])) |]

myconstmul : < Bounded 6 -> Bounded (mul 6 5) >
myconstmul = [| \x => ~(mulConstB 6 5 [|x|])
             |]
{-
{- little synthesisable const mul that uses our Bounded helper -}
myconstmul : < Bin (clog2 6) -> Bin (clog2 (S (mul 6 5))) >
myconstmul = [| \x => boundedToBin _
                        ~(mulConstB 6 5 [|MkB {6} {_} {Refl {_} {_}} x|])
             |]

data Vect' : Nat -> Type -> Type where
  VNil' : {a : Type} -> Vect' Z a
  VCons' : {a : Type} -> {k : Nat} ->
           a -> Vect' k a -> Vect' (S k) a
             
sum : (n : Nat) -> Vect' n Nat -> Nat
sum Z (VNil' {_}) = Z
pat n, x, xs =>
  sum (S n) (VCons' {_} {_} x xs) = plus x (sum n xs)

lemmaDotProd : (n, c, cs : Nat) ->
               Equal Nat (plus (mul c n) (mul n cs))
                         (mul n (plus c cs))
pat n, c, cs =>
  lemmaDotProd n c cs
    = let h1 = eqInd2 {_} {_} {_} {mulCommutative c n}
                 {\h => Equal Nat (plus (mul c n) (mul n cs))
                                  (plus h         (mul n cs))}
                 (Refl {_} {_})
          h2 = eqInd2 {_} {_} {_} {eqSym {_} {_} {_} (mulDistributesOverPlusRight n c cs)}
                 {\h => Equal Nat (plus (mul c n) (mul n cs)) h}
                 h1
      in h2

dotProd : (j,n : Nat) -> (ws : Vect' j Nat) ->
          < Vect j (Bounded n) > ->
          < Bounded (mul n (sum j ws)) >
pat n, xs =>
  dotProd Z n (VNil' {_}) xs = [| MkB {_} {_} {Refl {_} {_}} ~(zeroBin _) |]
pat j, n, w, ws, x, xs =>
  dotProd (S j) n (VCons' {_} {_} w ws) [|VCons {_} {_} x xs|]
    = [| let y = ~(addB _ _ (mulConstB _ w [|x|])
                            (dotProd _ _ ws [|xs|]))
         in eqInd2 {_} {_} {_} {lemmaDotProd n w (sum j ws)}
              {\h => Bounded h} y
      |]

-- Little synthesisable example of using dotProd
myws : Vect' 2 Nat
myws = VCons' {_} {_} 3 (VCons' {_} {_} 7 (VNil' {_}))

{- Doesn't compile --- Way forward might be to noticed single cons gadts and somehow optimise it away...
   Then we can synthesis Bounded directly. _OR_ Can just make the bounded nat explicit
-}
mydotprod : < Vect 2 (Bin (clog2 (S 6))) -> Vect 2 (Bin (clog2 (S 6))) > -- (clog2 (S (mul 6 (sum 2 myws)))) >
mydotprod = [| \xs => --let xs' = map 2 {_} {_} (MkB {6} {_} {Refl {_} {_}}) xs
                          --ans = xs' --ans = ~(dotProd 2 6 myws [|xs'|])
                      --in map 2 {_} {_} (boundedToBin 6) ans
                      map 2 _ _ (boundedToBin 6) (map 2 _ _ (MkB {6} {_} {Refl {_} {_}}) xs)

            |]

-- Issue is how do we find type of vnil? we've erased arg... maybe we should keep type annotations? don't know.
-- VNil with no a type is OK since it has no bits... where do we go wrong? Annotation of cons applied to a thing with a type?
-}