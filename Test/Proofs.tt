-- A playground for proofs and propositions

import Data.Nat

data Equal : (A : Type) -> (a : A) -> (b : A) -> Type where
  Refl : {A : Type} -> {x : A} -> Equal A x x

-- Let's play with some example of definitional equality.

twoPlusTwoEqFour : Equal Nat (plus 2 2) 4
twoPlusTwoEqFour = Refl {_} {_}

-- -- Checking 2 + 2 = 3 should type error
-- > twoPlusTwoEqThree : Equal Nat (plus 2 2) 3
-- > twoPlusTwoEqThree = Refl {_} {_}

eqInd : (A : Type) ->
        {x : A} ->
        {y : A} ->
        (p : Equal A x y) ->
        {P : (A -> Type)} ->
        (val : P x) ->
        P y
pat A : Type, x : A, P : (A -> Type), val : P x =>
  eqInd A {x} {x} (Refl {A} {x}) {P} val = val

-- This is maybe a bit problematic as a non-primitive rule...
-- We pattern match on the implicit Equal argument...
-- This is "OK" because there is only one constructor (Refl)
-- i.e. it is still an inaccesible pattern.
-- I don't think we actually have a special case for this in the language though
--
-- Would this be addressed by the same totality checking required for the eqInd
-- rule?
eqInd2 : {A : Type} ->
         {x : A} ->
         {y : A} ->
         {p : Equal A x y} ->
         {P : (A -> Type)} ->
         (val : P x) ->
         P y
pat A : Type, x : A, P : (A -> Type), val : P x =>
  eqInd2 {A} {x} {x} {Refl {A} {x}} {P} val = val

eqSym : {A : Type} ->
        {x : A} ->
        {y : A} ->
        (p : Equal A x y) ->
        Equal A y x
pat A : Type, x : A =>
  eqSym {A} {x} {x} (Refl {A} {x}) = Refl {_} {_}

eqTrans : {A : Type} ->
          {x,y,z : A} ->
          (l : Equal A x y) ->
          (r : Equal A y z) ->
          Equal A x z
pat A : Type, y : A =>
  eqTrans {A} {y} {y} {y} (Refl {A} {y}) (Refl {A} {y}) = Refl {_} {_}

eqCong : {A,B : Type} ->
         {f : A -> B} ->
         {x, y : A} ->
         (p : Equal A x y) ->
         Equal B (f x) (f y)
pat A, B : Type, f : (A->B), x : A =>
  eqCong {A} {B} {f} {x} {x} (Refl {A} {x}) = Refl {B} {f x}
         

-- Let's try to prove some of the Nat properties from Idris2's base Nat library
-- These are all pattern matching proofs, using the equality rules above.

natEqSucc : {left, right : Nat} ->
            Equal Nat left right ->
            Equal Nat (S left) (S right)
pat left : Nat =>
  natEqSucc {left} {left} (Refl {Nat} {left}) = Refl {Nat} {S left}
  -- Still makes me uncomfortable pattern matching on left left
  -- Also, our nats are all implicit since we're only pattern matching on the equality proof

natSuccInjective : {left, right : Nat} ->
                   Equal Nat (S left) (S right) ->
                   Equal Nat left right
pat left : Nat =>
  natSuccInjective {left} {left} (Refl {Nat} {S left}) = Refl {Nat} {left}

plusZeroLeftNeutral : (right : Nat) -> Equal Nat (plus 0 right) right
pat right : Nat =>
  plusZeroLeftNeutral right = Refl {Nat} {right}

plusZeroRightNeutral : (left : Nat) -> Equal Nat (plus left 0) left
plusZeroRightNeutral Z = Refl {Nat} {Z}
pat left : Nat =>
  plusZeroRightNeutral (S left)
    = let h = plusZeroRightNeutral left
      in eqCong {Nat} {Nat} {S} {plus left 0} {left} h

plusSuccRightSucc : (left, right : Nat) -> Equal Nat (S (plus left right)) (plus left (S right))
pat right : Nat =>
  plusSuccRightSucc Z right = Refl {Nat} {S right}
pat left, right : Nat =>
  plusSuccRightSucc (S left) right
    = let h = plusSuccRightSucc left right
      in eqCong {Nat} {Nat} {S} {S (plus left right)} {plus left (S right)} h
