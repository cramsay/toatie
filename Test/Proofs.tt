-- A playground for proofs and propositions

import Data.Nat

data Equal : (A : Type) -> (a : A) -> (b : A) -> Type where
  Refl : {A : Type} -> {x : A} -> Equal A x x

data Void : Type where
  {} -- Empty type! Just syntax for an empty block of constructors

-- Let's play with some example of definitional equality.

twoPlusTwoEqFour : Equal Nat (plus 2 2) 4
twoPlusTwoEqFour = Refl {_} {_}

-- -- Checking 2 + 2 = 3 should type error
-- > twoPlusTwoEqThree : Equal Nat (plus 2 2) 3
-- > twoPlusTwoEqThree = Refl {_} {_}

eqInd : (A : Type) ->
        {x : A} ->
        {y : A} ->
        (p : Equal A x y) ->
        {P : (A -> Type)} ->
        (val : P x) ->
        P y
pat A, x, P, val =>
  eqInd A {x} {_} (Refl {A} {x}) {P} val = val

eqInd2 : {A : Type} ->
         {x : A} ->
         {y : A} ->
         {p : Equal A x y} ->
         {P : (A -> Type)} ->
         (val : P x) ->
         P y
pat A x P val =>
  eqInd2 {A} {x} {_} {Refl {A} {x}} {P} val = val

eqSym : {A : Type} ->
        {x : A} ->
        {y : A} ->
        (p : Equal A x y) ->
        Equal A y x
pat A x =>
  eqSym {A} {x} {_} (Refl {A} {x}) = Refl {_} {_}

eqTrans : {A : Type} ->
          {x,y,z : A} ->
          (l : Equal A x y) ->
          (r : Equal A y z) ->
          Equal A x z
pat A y =>
  eqTrans {A} {y} {_} {_} (Refl {A} {y}) (Refl {A} {y}) = Refl {_} {_}

eqCong : {A,B : Type} ->
         {f : A -> B} ->
         {x, y : A} ->
         (p : Equal A x y) ->
         Equal B (f x) (f y)
pat A, B, f, x =>
  eqCong {A} {B} {f} {x} {_} (Refl {A} {x}) = Refl {B} {f x}
         

-- Let's try to prove some of the Nat properties from Idris2's base Nat library
-- These are all pattern matching proofs, using the equality rules above.

natEqSucc : {left, right : Nat} ->
            Equal Nat left right ->
            Equal Nat (S left) (S right)
pat left : Nat =>
  natEqSucc {left} {left} (Refl {Nat} {left}) = Refl {Nat} {S left}
  -- Still makes me uncomfortable pattern matching on left left
  -- Also, our nats are all implicit since we're only pattern matching on the equality proof

natSuccInjective : {left, right : Nat} ->
                   Equal Nat (S left) (S right) ->
                   Equal Nat left right
pat left =>
  natSuccInjective {left} {_} (Refl {Nat} {S left}) = Refl {_} {_}

plusZeroLeftNeutral : (right : Nat) -> Equal Nat (plus 0 right) right
pat right =>
  plusZeroLeftNeutral right = Refl {_} {_}

plusZeroRightNeutral : (left : Nat) -> Equal Nat (plus left 0) left
plusZeroRightNeutral Z = Refl {_} {_}
pat left =>
  plusZeroRightNeutral (S left)
    = let h = plusZeroRightNeutral left
      in eqCong {_} {_} {S} {_} {_} h

plusSuccRightSucc : (left, right : Nat) -> Equal Nat (S (plus left right)) (plus left (S right))
pat right =>
  plusSuccRightSucc Z right = Refl {Nat} {S right}
pat left, right =>
  plusSuccRightSucc (S left) right
    = let h = plusSuccRightSucc left right
      in eqCong {_} {_} {S} {_} {_} h

plusAssociative : (left, centre, right : Nat) ->
                  Equal Nat (plus left (plus centre right))
                            (plus (plus left centre) right)
pat centre, right =>
  plusAssociative Z centre right = Refl {_} {_}
pat left, centre, right =>
  plusAssociative (S left) centre right =
    let h = plusAssociative left centre right
    in eqCong {_} {_} {S} {_} {_} h

plusCommutative : (left, right : Nat) -> Equal Nat (plus left right)
                                                   (plus right left)
pat right =>
  plusCommutative Z right
    = eqSym {_} {_} {_} (plusZeroRightNeutral right)
pat left, right =>
  plusCommutative (S left) right
    = let h1 = plusCommutative left right
          h2 = eqCong {_} {_} {S} {_} {_} h1
          h3 = eqInd2 {_} {_} {_} {plusSuccRightSucc right left}
                      {\x => Equal Nat (S (plus left right)) x} h2
      in h3


doubleAssociative : (a,b : Nat) -> Equal Nat (double (plus a b))
                                             (plus (double a) (double b))
pat a, b =>
  doubleAssociative a b
    = let h1 = Refl {Nat} {double (plus a b)}
          h2 = eqInd2 {_} {_} {_} {eqSym {_} {_} {_} (plusAssociative a b (plus a b))}
                                  {\n => Equal Nat (double (plus a b)) n } h1
          h3 = eqInd2 {_} {_} {_} {plusCommutative b (plus a b)}
                                  {\n => Equal Nat (double (plus a b)) (plus a n)} h2
          h4 = eqInd2 {_} {_} {_} { eqSym {_} {_} {_} (plusAssociative a b b) }
                                  {\n => Equal Nat (double (plus a b)) (plus a n)} h3
          h5 = eqInd2 {_} {_} {_} { plusAssociative a a (plus b b) }
                                  {\n => Equal Nat (double (plus a b)) n} h4
      in h5

plusPlusAssociative : (a,b,c,d : Nat) -> Equal Nat (plus (plus a b) (plus c d))
                                                   (plus (plus a c) (plus b d))
pat a,b,c,d =>
  plusPlusAssociative a b c d
    = let h1 = Refl {Nat} {plus (plus a b) (plus c d)}
          h2 = eqInd2 {_} {_} {_} {eqSym {_} {_} {_} (plusAssociative a b (plus c d))}
                                  {\n => Equal Nat (plus (plus a b) (plus c d)) n} h1
          h3 = eqInd2 {_} {_} {_} {plusCommutative b (plus c d)}
                                  {\n => Equal Nat (plus (plus a b) (plus c d)) (plus a n)} h2
          h4 = eqInd2 {_} {_} {_} {eqSym {_} {_} {_} (plusAssociative c d b)}
                                  {\n => Equal Nat (plus (plus a b) (plus c d)) (plus a n)} h3
          h5 = eqInd2 {_} {_} {_} {plusCommutative d b}
                                  {\n => Equal Nat (plus (plus a b) (plus c d)) (plus a (plus c n))} h4
          h6 = eqInd2 {_} {_} {_} {plusAssociative a c (plus b d)}
                                  {\n => Equal Nat (plus (plus a b) (plus c d)) n} h5
      in h6

plusEqZeroRight : (a, b : Nat) -> Equal Nat (plus a b) 0 ->
                                  Equal Nat b 0
pat b, prf =>
  plusEqZeroRight Z b prf = prf
pat n, b =>
  plusEqZeroRight (S n) b (Refl {_} {_}) impossible

plusEqZeroLeft : (a, b : Nat) -> Equal Nat (plus a b) 0 ->
                                 Equal Nat a 0
pat a, b, prf =>
  plusEqZeroLeft a b prf
    = let h1 = eqInd _ {_} {_} (plusCommutative a b)
                               {\x => Equal Nat x 0} prf
          in plusEqZeroRight b a h1

plusDoubleEq1ImpliesZ : (a, b : Nat) -> Equal Nat (plus a (plus b b)) 1
                                     -> Equal Nat b 0
pat a, prf =>
  plusDoubleEq1ImpliesZ a Z prf = Refl {_} {_}
pat n, a, prf =>
  plusDoubleEq1ImpliesZ a (S n) prf
    = let h1 = eqInd _ {_} {_} (eqSym {_} {_} {_} (plusSuccRightSucc a (plus n (S n))))
                               {\x => Equal Nat x 1}
                               prf
          h2 = eqInd _ {_} {_} (eqSym {_} {_} {_} (plusSuccRightSucc n n))
                               {\x => Equal Nat (S (plus a x)) 1}
                               h1
          h3 = eqInd _ {_} {_} (eqSym {_} {_} {_} (plusSuccRightSucc a (plus n n)))
                               {\x => Equal Nat (S x) 1}
                               h2
      in case h3 of
           Refl {_} {_} impossible