import Data.Nat
import Data.ZZ
import Proofs

data Vect : Nat -> Type -> Type where
     VNil : {a : Type} -> Vect Z a
     VCons : {a : Type} -> {k : Nat} ->
             a -> Vect k a -> Vect (S k) a

head : {a : Type} -> {n : Nat} -> Vect (S n) a -> a
pat a : Type =>
  head {a} {Z} (VNil {a}) impossible
pat a : Type, n : Nat, x : a, xs : Vect n a =>
  head {a} {n} (VCons {a} {n} x xs) = x

tail : {a : Type} -> {n : Nat} -> Vect (S n) a -> Vect n a
pat a : Type, n : Nat, x : a, xs : Vect n a =>
  tail {a} {n} (VCons {a} {n} x xs) = xs

append : {a : Type} -> {n : Nat} -> {m : Nat} -> Vect n a -> Vect m a -> Vect (plus n m) a
pat a : Type, m : Nat, ys : Vect m a =>
  append {a} {Z} {m} (VNil {a}) ys = ys
pat a : Type, n : Nat, m : Nat, x : a, xs : Vect n a, ys : Vect m a =>
  append {a} {S n} {m} (VCons {a} {n} x xs) ys = VCons {a} {plus n m} x (append {a} {n} {m} xs ys)

map : (n : Nat) -> {a : Type} -> {b : Type} ->
      (f : a -> b) ->
      Vect n a -> Vect n b
pat a, b, f =>
  map Z {a} {b} f (VNil {a}) = VNil {b}
pat n, a, b, f, xs =>
  map (S n) {a} {b} f xs =
    let y  = f (head {a} {n} xs)
        ys = map n {a} {b} f (tail {a} {n} xs)
    in VCons {b} {n} y ys

imap' : (i : Nat) -> (n : Nat) -> {a : Type} -> {b : Type} ->
      (f : Nat -> a -> b) ->
      Vect n a -> Vect n b
pat i, a, b, f =>
  imap' i Z {a} {b} f (VNil {a}) = VNil {b}
pat i, n, a, b, f, xs =>
  imap' i (S n) {a} {b} f xs =
    let y  = f i (head {a} {n} xs)
        ys = imap' (S i) n {a} {b} f (tail {a} {n} xs)
    in VCons {b} {n} y ys

imap : (n : Nat) -> {a : Type} -> {b : Type} ->
      (f : Nat -> a -> b) ->
      Vect n a -> Vect n b
pat n, a, b, f, xs =>
  imap n {a} {b} f xs = imap' 0 n {a} {b} f xs

foldl : (n : Nat) -> {acc : Type} -> {elem : Type} ->
        (f : acc -> elem -> acc) ->
        (init : acc) ->
        Vect n elem -> acc
pat acc, elem, f, init =>
  foldl Z {acc} {elem} f init (VNil {elem}) =  init
pat n, acc, elem, f, init, xs =>
  foldl (S n) {acc} {elem} f init xs =
    let init = f init (head {elem} {n} xs)
    in foldl n {acc} {elem} f init (tail {elem} {n} xs)

zipWith : (n : Nat) -> {a, b, c : Type} ->
          (f : a -> b -> c) ->
          Vect n a -> Vect n b -> Vect n c
pat a, b, c, f =>
  zipWith Z {a} {b} {c} f [] [] = []
pat n, a, b, c, f, x, xs, y, ys =>
  zipWith (S n) {a} {b} {c} f (VCons {a} {n} x xs) (VCons {b} {n} y ys) =
    let z  = f x y
        zs = zipWith n {a} {b} {c} f xs ys
    in VCons {c} {n} z zs

consPair : (n : Nat) -> {a : Type} -> (x, y : a) -> Vect 2 (Vect n a) -> Vect 2 (Vect (S n) a)
pat n, a, x, y, xs, ys =>
  consPair n {a} x y [xs, ys] = [VCons {_} {_} x xs, VCons {_} {_} y ys]

pairCons : (n : Nat) -> {a : Type} -> (x, y : a) -> Vect (plus n n) a -> Vect (plus (S n) (S n)) a
pat n, a, x, y, xs =>
  pairCons n {a} x y xs = let ans = VCons {a} {S (plus n n)} x (VCons {a} {plus n n} y xs)
                          in eqInd2 {_} {_} {_} {plusSuccRightSucc (S n) n}
                               {\h => Vect h a} ans

interleave : (n : Nat) -> {a : Type} -> Vect 2 (Vect n a) -> Vect (plus n n) a
pat a, xs =>
  interleave Z {a} xs = []
pat n, a, x, xs, y, ys =>
  interleave (S n) {a} [(VCons {_} {_} x xs), (VCons {_} {_} y ys)]
    = pairCons n {a} x y (interleave n {_} [xs, ys])

deinterleave : (n : Nat) -> {a : Type} -> Vect (plus n n) a -> Vect 2 (Vect n a)
pat a =>
  deinterleave Z {a} [] = [[], []]
pat a, x, y =>
  deinterleave 1 {a} [x,y] = [[x], [y]]
pat n, a, x, y, rest =>
  deinterleave (S (S n)) {a} (VCons {_} {_} x (VCons {_} {_} y rest))
    = let rest' = eqInd2 {_} {_} {_} {eqSym {_} {_} {_} (plusSuccRightSucc n (S n))} {\h => Vect h a} rest
          deiRest = deinterleave (S n) {a} rest'
      in consPair (S n) {a} x y deiRest

-- Specialsed arithmetic functions for ZZ (used in FFT example)

sumZ : (n : Nat) -> Vect n ZZ -> ZZ
sumZ Z (VNil {ZZ}) = Pos 0
pat n, x, xs =>
  sumZ (S n) (VCons {_} {_} x xs) = plusZ x (sumZ n xs)

prfInterleaveConsPair : (n : Nat) -> {a : Type} ->
                        (x, y : a) -> (rest : Vect 2 (Vect (S n) a)) ->
                        Equal (Vect (plus (S (S n)) (S (S n))) a)
                          (interleave (S (S n)) {a} (consPair (S n) {a} x y rest))
                          (pairCons (S n) {a} x y (interleave (S n) {a} rest))
pat a, x, y, e, o =>
  prfInterleaveConsPair Z {a} x y [e,o] = Refl {_} {_}
pat n, a, x, y, e, es, o, os =>
  prfInterleaveConsPair (S n) {a} x y [VCons {_} {_} e es, VCons {_} {_} o os]
    = Refl {_} {_}

{-
prfInterleaveSym' : (n : Nat) -> {a : Type} ->
                    (xs : Vect (plus (S n) (S n)) a) ->
                    (x, y : a) -> (rest : Vect (plus n n) a) ->
                    Equal (Vect (plus (S n) (S n)) a)
                      xs
                      (pairCons n {a} x y rest) ->
                    Equal (Vect (plus (S n) (S n)) a)
                      xs
                      (interleave (S n) {a} (deinterleave (S n) {a} xs))
pat a, x, y, prf =>
  prfInterleaveSym' Z {a} [x,y] x y [] prf = Refl {_} {_}
pat n, a, xs, x, y, rest, prf =>
  prfInterleaveSym' (S n) {a} xs x y rest prf
    = let h1 = Refl {_} {interleave (S (S n)) {a} (deinterleave (S (S n)) {a} xs)}
          h2 = eqInd2 {_} {_} {_} {prf}
                {\h => Equal (Vect (plus (S (S n)) (S (S n))) a)
                         (interleave (S (S n)) {a} (deinterleave (S (S n)) {a} h ))
                         (interleave (S (S n)) {a} (deinterleave (S (S n)) {a} xs))
                } h1
                         
      in _
-}


lemmaInterleaveSym : {a : Type} -> (n : Nat) -> (x, y : a) -> (rest : Vect (plus n (S (S n))) a) ->
                     Equal (Vect (plus (S (S n)) (S (S n))) a)
                       (eqInd2 {_} {_} {_} {(eqCong {_} {_} {S} {_} {_} (eqCong {_} {_} {S} {_} {_} (plusSuccRightSucc n (S n))))} {\h => (Vect h a)}
                         (VCons {a} {(S (S (plus n (S n))))}
                           x
                           (VCons {a} {(S (plus n (S n)))}
                             y
                             (eqInd2 {Nat} {(plus n (S (S n)))} {(S (plus n (S n)))} {(eqSym {Nat} {(S (plus n (S n)))} {(plus n (S (S n)))} (plusSuccRightSucc n (S n)))} {\h : Nat => (Vect h a)} rest)))
                       )
                       (VCons {a} {(S (plus n (S (S n))))} x (VCons {a} {(plus n (S (S n)))} y rest))
pat a, x, y, e, o =>
  lemmaInterleaveSym {a} Z x y [e,o] = Refl {_} {_}
pat a, x, y, e, o, e', o' =>
  lemmaInterleaveSym {a} 1 x y [e,o,e',o'] = Refl {_} {_}
pat n, a, x, y, e, o, rest =>
  lemmaInterleaveSym {a} (S (S n)) x y (VCons {_} {_} e (VCons {_} {_} o rest)) = _

prfInterleaveSym : (n : Nat) -> {a : Type} ->
                   (xs : Vect (plus n n) a) ->
                   Equal (Vect (plus n n) a)
                     xs
                     (interleave n {a} (deinterleave n {a} xs))
pat a =>
  prfInterleaveSym Z {a} [] = Refl {_} {_}
pat a, x, y =>
  prfInterleaveSym 1 {a} [x,y] = Refl {_} {_}
pat n, a, x, y, rest =>
  prfInterleaveSym (S (S n)) {a} (VCons {_} {_} x (VCons {_} {_} y rest))
    = let rest' = eqInd2 {_} {_} {_} {eqSym {_} {_} {_} (plusSuccRightSucc n (S n))} {\h => Vect h a} rest
          h1 = eqInd2 {_} {_} {_} {prfInterleaveConsPair n {a} x y (deinterleave (S n) {a}
                                     (eqInd2 {_} {_} {_} {eqSym {_} {_} {_} (plusSuccRightSucc n (S n))} {\h => Vect h a} rest))}
                 {\h => Equal (Vect (plus (S (S n)) (S (S n))) a)
                          h
                          (interleave (S (S n)) {a} (consPair (S n) {a} x y (deinterleave (S n) {a}
                           (eqInd2 {_} {_} {_} {eqSym {_} {_} {_} (plusSuccRightSucc n (S n))} {\h => Vect h a} rest))))
                 } (Refl {_} {_})
          h2 = eqInd2 {_} {_} {_} {eqSym {_} {_} {_} (prfInterleaveSym (S n) {a} (eqInd2 {_} {_} {_} {eqSym {_} {_} {_} (plusSuccRightSucc n (S n))} {\h => Vect h a} rest))}
             {\h => Equal (Vect (plus (S (S n)) (S (S n))) a)
                      (pairCons (S n) {a} x y h)
                      (interleave (S (S n)) {a} (consPair (S n) {a} x y (deinterleave (S n) {a}
                       (eqInd2 {_} {_} {_} {eqSym {_} {_} {_} (plusSuccRightSucc n (S n))} {\h => Vect h a} rest))))
             } h1
      in eqInd2 {_} {_} {_} {lemmaInterleaveSym {a} n x y rest}
           {\h => Equal (Vect (plus (S (S n)) (S (S n))) a)
                    h
                    (interleave (S (S n)) {a} (consPair (S n) {a} x y (deinterleave (S n) {a}
                     (eqInd2 {_} {_} {_} {eqSym {_} {_} {_} (plusSuccRightSucc n (S n))} {\h => Vect h a} rest))))
           } h2

{-

--------------------------------


-}