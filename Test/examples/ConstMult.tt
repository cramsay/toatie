import Data.Bool
import Data.Nat
import Data.Unsigned

lte : Nat -> Nat -> Bool
pat right =>
  lte Z right = True
pat left =>
  lte left Z = False
pat left, right =>
  lte (S left) (S right) = lte left right

minus : Nat -> Nat -> Nat
pat right =>
  minus Z right = Z
pat left =>
  minus left Z = left
pat left, right =>
  minus (S left) (S right) = minus left right

data NonZero : Nat -> Type where
  SIsNonZero : (x : Nat) -> NonZero (S x)

-- mod' fuel a b = a `mod` (S b)
-- assuming we have enough fuel
mod' : Nat -> Nat -> Nat -> Nat
pat centre, right =>
  mod' Z centre right = centre
pat fuel, centre, right =>
  mod' (S fuel) centre right =
    case lte centre right of
      True  ==> centre
      False ==> mod' fuel (minus centre (S right)) right

modNatNZ : Nat -> (y : Nat) -> NonZero y -> Nat
pat left, right =>
  modNatNZ left (S right) (SIsNonZero right) = mod' left left right

-- div' fuel a b = a `div` (S b)
-- assuming we have enough fuel
div' : Nat -> Nat -> Nat -> Nat
pat centre, right =>
  div' Z centre right = Z
pat fuel, centre, right =>
  div' (S fuel) centre right =
    case lte centre right of
      True  ==> Z
      False ==> S (div' fuel (minus centre (S right)) right)

divNatNZ : Nat -> (y : Nat) -> NonZero y -> Nat
pat left, right =>
  divNatNZ left (S right) (SIsNonZero right) = div' left left right

flog2 : Nat -> Nat
flog2 Z = Z
flog2 1 = Z
pat n =>
  flog2 n = plus 1 (flog2 (divNatNZ n 2 (SIsNonZero 1)))

clog2 : Nat -> Nat
clog2 Z = Z
pat n =>
  clog2 (S n) = S (flog2 n)

zerosU : (w : Nat) -> Unsigned w 0
zerosU Z = UNil
pat w =>
  zerosU (S w) = UCons {_} {_} {_} (zerosU w) O























-- Dependent Pair
data DPair : (a : Type) -> (P : a -> Type) -> Type where
  MkDPair : {a : Type} -> {P : a -> Type} -> (x : a) -> (pf : P x) -> DPair a P

-- View for dividing a Nat in half
data Half : Nat -> Type where
     HalfOdd : (n : Nat) -> Half (S (plus n n))
     HalfEven : (n : Nat) -> Half (plus n n)

-- View for recursively dividing a Nat in half
data HalfRec : Nat -> Type where
     HalfRecZ : HalfRec Z
     HalfRecEven : (n : Nat) -> HalfRec n -> HalfRec (plus n n)
     HalfRecOdd  : (n : Nat) -> HalfRec n -> HalfRec (S (plus n n))

-- We don't have heuristics to ensure we match on the `Half` arg before our Nat
-- Instead, we encourage toatie to match on the `Half` by introducing `n` as implicit
half' :  {n : Nat} -> Half n -> Half (S n)
pat k =>
  half' {S (plus k k)} (HalfOdd k)
    = eqInd2 {_} {_} {_} {eqSym {_} {_} {_} (plusSuccRightSucc (S k) k)} {_}
        (HalfEven (S k))
pat k =>
  half' {plus k k} (HalfEven k) = HalfOdd k

half :  (n : Nat) -> Half n
half Z = HalfEven Z
pat n =>
  half (S n) = half' {n} (half n)

halfRec :  (n : Nat) -> HalfRec n
halfRec' :  {n : Nat} -> Half n -> HalfRec (S n)

pat k =>
  halfRec' {plus k k} (HalfEven k) = HalfRecOdd _ (halfRec k)
pat k =>
  halfRec' {S (plus k k)} (HalfOdd k)
    = eqInd2 {_} {_} {_} {eqSym {_} {_} {_} (plusSuccRightSucc (S k) k)} {_}
        (HalfRecEven (S k) (halfRec (S k)))

halfRec Z = HalfRecZ
pat n =>
  halfRec (S n) = halfRec' {n} (half n)

natBits' : {n : Nat} -> Half n -> Nat
natBits' {_} (HalfEven 0) = 0
pat k =>
  natBits' {_} (HalfEven (S k)) = S (natBits' {S k} (half (S k)))
pat k =>
  natBits' {_} (HalfOdd k) = S (natBits' {k} (half k))

natBits : Nat -> Nat
pat n =>
  natBits n = natBits' {n} (half n)

bitsMax : Nat -> Nat
pat b =>
  bitsMax b = minus (pow 2 b) 1

halfToUnsigned : {n : Nat} -> HalfRec n -> DPair Nat (\w  => Unsigned w n)
halfToUnsigned {Z} HalfRecZ = MkDPair {_} {\w => Unsigned w Z} Z UNil
pat k, rec =>
  halfToUnsigned {plus k k} (HalfRecEven k rec) =
    case (halfToUnsigned {k} rec) of
      pat w, xs =>
        MkDPair {_} {_} w xs ==> MkDPair {_} {\w => Unsigned w (plus k k)}
                                   (S w)
                                   (UCons {_} {_} {_} xs O)
pat k, rec =>
  halfToUnsigned {S (plus k k)} (HalfRecOdd k rec) =
    case (halfToUnsigned {k} rec) of
      pat w, xs =>
        MkDPair {_} {_} w xs ==> MkDPair {_} {\w => Unsigned w (S (plus k k))}
                                   (S w)
                                   (UCons {_} {_} {_} xs I)

natToUnsigned : (n : Nat) -> DPair Nat (\w  => Unsigned w n)
pat n =>
  natToUnsigned n = halfToUnsigned {n} (halfRec n)

prfShiftLeft : (a, b : Nat) -> Equal Nat
                                     (plus (mul (pow 2 a) b)
                                           (mul (pow 2 a) b))
                                     (mul (pow 2 (S a)) b)
pat a, b =>
  prfShiftLeft a b
    = let h1 = Refl {_} {mul (pow 2 (S a)) b}
          h2 = eqInd2 {_} {_} {_} {powerPlusMulPower 2 1 a}
                 {\x => Equal Nat (mul (mul 2 (pow 2 a)) b)
                                  (mul (pow 2 (S a)) b)}
                 h1
          h3 = eqInd2 {_} {_} {_} {plusZeroRightNeutral (pow 2 a)}
                 {\x => Equal Nat (mul (plus (pow 2 a) x) b)
                                  (mul (pow 2 (S a)) b)} h2
      in eqInd2 {_} {_} {_} {mulDistributesOverPlusLeft (pow 2 a) (pow 2 a) b}
           {\x => Equal Nat x (mul (pow 2 (S a)) b)} h3

shiftLeft : (n, w : Nat) -> {val : Nat} -> < Unsigned w val > -> < Unsigned (plus n w) (mul (pow 2 n) val) >
pat w, val, xs =>
  shiftLeft Z w {val} xs = [|
    eqInd2 {_} {_} {_} {eqSym {_} {_} {_} (plusZeroRightNeutral val)} {_} ~xs
  |]
pat n, w, val, xs =>
  shiftLeft (S n) w {val} xs = [|
    let rec = ~(shiftLeft n w {val} xs)
        ans = UCons {plus n w} {mul (pow 2 n) val} {0} rec O
    in eqInd2 {_} {_} {_} {prfShiftLeft n val} {_} ans
  |]

{-
prfHalfDouble : {n : Nat} -> Half n -> Equal (Half (plus n n)) (half (plus n n)) (HalfEven n)
prfHalfDouble {Z} (HalfEven Z) = Refl {_} {_}
pat n =>
  prfHalfDouble {plus (S n) (S n)} (HalfEven (S n))
    = let rec = prfHalfDouble {S n} (half (S n))
      in Refl {_} {_}
-}
{-
Equal 
        (half (plus (S n) (S n)))
        (HalfEven (S n))
--------------------------------
Equal
       (half {(plus (plus (S n) (S n)) ((plus (S n) (S n))))}
       (HalfEven ((plus (S n) (S n))))


-}

{-
prfMultNatUWidth  : {a : Nat} -> Half (S a) ->
                    Equal Nat (S (natBits (S a)))
                              (natBits (plus (S a) (S a)))
prfMultNatUWidth {Z} (HalfOdd Z) = Refl {_} {_}
pat n =>
  prfMultNatUWidth {plus (S n) (S n)} (HalfOdd (S n)) = let rec = prfMultNatUWidth {n} (half (S n))
                                            in _

Equal Nat (S (natBits (S n)))
          (natBits (S (plus n (S n)))
--------------------------------
Equal Nat (S (natBits' {(S (S (plus n (S n))))} (half' {(S (plus n (S n)))} (half' {(plus n (S n))} (half (plus n (S n))))))) (natBits' {(S (S (plus (plus n (S n)) (S (S (plus n (S n)))))))} (half' {(S (plus (plus n (S n)) (S (S (plus n (S n))))))} (half' {(plus (plus n (S n)) (S (S (plus n (S n)))))} (half (plus (plus n (S n)) (S (S (plus n (S n)))))))))



(Equal Nat (S (natBits' {(S a)}
           (natBits' {(S (plus a (S a)))} 
--------------------------------
(Equal Nat (S (natBits' {(S (S a))})
           (natBits' {(S (S (plus a (S (S a)))))}





prfMultNatUEmpty : (c : Nat) -> Equal Nat 0 (natBits (mul c (bitsMax 0)))
pat c =>
  prfMultNatUEmpty c = let h1 = Refl {_} {natBits (mul c (bitsMax 0))}
                       in eqInd2 {_} {_} {_} {mulZeroRightZero c}
                            {\x => Equal Nat (natBits x) (natBits (mul c (bitsMax 0)))} h1
-}

{-
multNatU : (w : Nat) -> {c,val : Nat} -> HalfRec c -> < Unsigned w val > ->
           < Unsigned (plus (natBits c) w) (mul c val) >
pat w, val, xs =>
  multNatU w {0} {val} HalfRecZ xs = [| zerosU w |]
pat w, val, xs, hrec =>
  multNatU w {0} {val} (HalfRecEven 0 hrec) xs = [| zerosU w |]
pat w, val, xs, k, hrec =>
  multNatU w {plus (S k) (S k)} {val} (HalfRecEven (S k) hrec) xs
  = [| let rec = ~(multNatU w {(S k)} {val} hrec xs)
           ans = ~(shiftLeft 1 _ {_} [| rec |])
       in _
    |]
pat w, val, xs, k, hrec =>
  multNatU w {_} {val} (HalfRecOdd k hrec) xs = _
-}

extend : (w', w : Nat) -> {val : Nat} ->
         < Unsigned w val > ->
         < Unsigned (plus w' w) val >
pat w, val, xs =>
  extend Z w {val} xs = xs
pat w' =>
  extend (S w') Z {0} [| UNil |]
    = let ans = extend w' 1 {_} [| UCons {_} {_} {_} UNil O |]
      in eqInd2 {_} {_} {_} {eqSym {_} {_} {_} (plusSuccRightSucc w' 0)}
           {\h => <Unsigned h 0>} ans
pat w', w, val, xsval, xval, xs, x =>
  extend (S w') (S w) {_} [| UCons {w} {xsval} {xval} xs x |]
    = [| let rec = ~( eqInd2 {_} {_} {_} {plusSuccRightSucc w' w}
                        {\h => <Unsigned h xsval>}
                        (extend (S w') w {xsval} [|xs|])
                    )
         in UCons {_} {_} {_} rec x
      |]

multConstU' : (w : Nat) -> {cval, val : Nat} ->
             HalfRec cval ->
             < Unsigned w val > ->
             DPair Nat (\w' : Nat => < Unsigned w' (mul cval val) >)
pat w, val, xs =>
  multConstU' w {Z} {val} HalfRecZ xs = MkDPair {_} {_} 0 [| UNil |]
pat cval, hr =>
  multConstU' Z {cval} {Z} hr [| UNil |] = MkDPair {_} {_} 0 [| UNil |]
pat n, w, val, xs, hrec =>
  multConstU' (S w) {plus (S n) (S n)} {val} (HalfRecEven (S n) hrec) xs
    = case multConstU' (S w) {S n} {val} hrec xs of
           pat w' : Nat, rec : <Unsigned w' (mul (S n) val)> =>
             MkDPair {Nat} {\a:Nat => Unsigned a (mul (S n) val)} w' rec ==>
               let ans = [| UCons {w'} {mul (S n) val} {0} ~rec O |]
               in _ --MkDPair {_} {_} (S w') (
                  --  eqInd2 {_} {_} {_} {eqSym {_} {_} {_} (mulDistributesOverPlusLeft (S n) (S n) val)} {\h : Nat => <Unsigned (S w') h >} ans)
      
pat n, w, val, xs, hrec =>
  multConstU' (S w) {S (plus n n)} {val} (HalfRecOdd n hrec) xs
    = _

{-
pat w, xval, xs =>
  multConstU Z w {0} {xval} UNil xs = [| zerosU w |]
pat cw, w, cval, xval, cs : Unsigned cw cval, xs =>
  multConstU (S cw) w {_} {xval} (UCons {cw} {cval} {0} cs O) xs = [|
    let rec = ~(multConstU _ _ {_} {_} cs xs)
        ans = UCons {_} {mul cval xval} {0} rec O
    in eqInd2 {_} {_} {_}
         {eqSym {_} {_} {_} (mulDistributesOverPlusLeft cval cval xval)}
         {_} ans
  |]
pat cw, w, cval, xval, cs : Unsigned cw cval, xs =>
  multConstU (S cw) w {_} {xval} (UCons {cw} {cval} {1} cs I) xs = [|
    let rec = ~(multConstU _ _ {_} {_} cs xs)
        recPad = UCons {_} {mul cval xval} {0} rec O
        ans = ~(addU _ {_} {_} {0} [| recPad |] (extend w {xval} xs) [| O |])
    in _ --eqInd2 {_} {_} {_}
       --  {eqSym {_} {_} {_} (mulDistributesOverPlusLeft cval cval xval)}
       --  {_} ans
  |]
-}