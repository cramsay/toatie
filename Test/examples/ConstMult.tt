import Data.Bool
import Data.Nat
import Data.Unsigned

data LTE  : (n, m : Nat) -> Type where
  LTEZero : {right : Nat} -> LTE Z right
  LTESucc : {left, right : Nat} -> LTE left right -> LTE (S left) (S right)

plusMinusLTE : (x, y : Nat) -> LTE y x -> Equal Nat (plus (minus x y) y) x
pat x, lte =>
  plusMinusLTE x Z lte
    = let h1 = eqInd2 {_} {_} {_} {minusZeroRight x}
                 {\h => Equal Nat (plus (minus x 0) 0) (plus h 0)}
                 (Refl {_} {_})
      in eqInd2 {_} {_} {_} {plusZeroRightNeutral x}
           {_} h1
pat y =>
  plusMinusLTE Z (S y) (LTEZero {_}) impossible
pat y =>
  plusMinusLTE Z (S y) (LTESucc {y} {_} _) impossible
pat x, y, lte : LTE y x =>
  plusMinusLTE (S x) (S y) (LTESucc {y} {x} lte)
    = let h0 = plusMinusLTE x y lte
          h1 = eqCong {_} {_} {S} {_} {_} h0
          h2 = eqInd2 {_} {_} {_} {plusSuccRightSucc (minus x y) y}
                 {\h => Equal Nat h (S x) }
                 h1
      in h2

maxZeroRightNeutral : (n : Nat) -> Equal Nat (max n 0) n
maxZeroRightNeutral Z = Refl {_} {_}
pat n =>
  maxZeroRightNeutral (S n) = Refl {_} {_}

maxZeroLeftNeutral : (n : Nat) -> Equal Nat (max 0 n) n
maxZeroLeftNeutral Z = Refl {_} {_}
pat n =>
  maxZeroLeftNeutral (S n) = Refl {_} {_}

maxLeftImpliesLTE : (x, y : Nat) -> LTE x (max x y)
maxLeftImpliesLTE Z Z = LTEZero {Z}
pat x =>
  maxLeftImpliesLTE (S x) Z = LTESucc {x} {x} (
                                eqInd2 {_} {_} {_} {maxZeroRightNeutral x} {_}
                                  (maxLeftImpliesLTE x Z))
pat y =>
  maxLeftImpliesLTE Z y = LTEZero {y}
pat x, y =>
  maxLeftImpliesLTE (S x) (S y) = LTESucc {x} {max x y} (maxLeftImpliesLTE x y)

maxRightImpliesLTE : (x, y : Nat) -> LTE y (max x y)
maxRightImpliesLTE Z Z = LTEZero {Z}
pat y =>
  maxRightImpliesLTE Z (S y) = LTESucc {y} {y} (
                                eqInd2 {_} {_} {_} {maxZeroLeftNeutral y} {_}
                                  (maxRightImpliesLTE Z y))
pat x =>
  maxRightImpliesLTE x Z = LTEZero {max x Z}
pat x, y =>
  maxRightImpliesLTE (S x) (S y) = LTESucc {y} {max x y} (maxRightImpliesLTE x y)

zerosU : (w : Nat) -> Unsigned w 0
zerosU Z = UNil
pat w =>
  zerosU (S w) = UCons {_} {_} {_} (zerosU w) O

-- Think we're golden if we can prove that log2 (pow 2 x) = x
-- Is that even more general than our current problem though? Probably
--
-- Oh shit, do I need the precondition that our input (S n) is a power of two?
-- Well, we kinda know that right?





















-- Dependent Pair
data DPair : (a : Type) -> (P : a -> Type) -> Type where
  MkDPair : {a : Type} -> {P : a -> Type} -> (x : a) -> (pf : P x) -> DPair a P

-- View for dividing a Nat in half
data Half : Nat -> Type where
     HalfOdd : (n : Nat) -> Half (S (plus n n))
     HalfEven : (n : Nat) -> Half (plus n n)

-- View for recursively dividing a Nat in half
data HalfRec : Nat -> Type where
     HalfRecZ : HalfRec Z
     HalfRecEven : (n : Nat) -> HalfRec (S n) -> HalfRec (plus (S n) (S n))
     HalfRecOdd  : (n : Nat) -> HalfRec n -> HalfRec (S (plus n n))

-- We don't have heuristics to ensure we match on the `Half` arg before our Nat
-- Instead, we encourage toatie to match on the `Half` by introducing `n` as implicit
half' :  {n : Nat} -> Half n -> Half (S n)
pat k =>
  half' {S (plus k k)} (HalfOdd k)
    = eqInd2 {_} {_} {_} {eqSym {_} {_} {_} (plusSuccRightSucc (S k) k)} {_}
        (HalfEven (S k))
pat k =>
  half' {plus k k} (HalfEven k) = HalfOdd k

half :  (n : Nat) -> Half n
half Z = HalfEven Z
pat n =>
  half (S n) = half' {n} (half n)

halfRec :  (n : Nat) -> HalfRec n
halfRec' :  {n : Nat} -> Half n -> HalfRec (S n)

pat k =>
  halfRec' {plus k k} (HalfEven k) = HalfRecOdd _ (halfRec k)
pat k =>
  halfRec' {S (plus k k)} (HalfOdd k)
    = eqInd2 {_} {_} {_} {eqSym {_} {_} {_} (plusSuccRightSucc (S k) k)} {_}
        (HalfRecEven k (halfRec (S k)))

halfRec Z = HalfRecZ
pat n =>
  halfRec (S n) = halfRec' {n} (half n)

natBits' : {n : Nat} -> Half n -> Nat
natBits' {_} (HalfEven 0) = 0
pat k =>
  natBits' {_} (HalfEven (S k)) = S (natBits' {S k} (half (S k)))
pat k =>
  natBits' {_} (HalfOdd k) = S (natBits' {k} (half k))

natBits : Nat -> Nat
pat n =>
  natBits n = natBits' {n} (half n)

bitsMax : Nat -> Nat
pat b =>
  bitsMax b = minus (pow 2 b) 1

{-
halfToUnsigned : {n : Nat} -> HalfRec n -> DPair Nat (\w  => Unsigned w n)
halfToUnsigned {Z} HalfRecZ = MkDPair {_} {\w => Unsigned w Z} Z UNil
pat k, rec =>
  halfToUnsigned {plus k k} (HalfRecEven k rec) =
    case (halfToUnsigned {k} rec) of
      pat w, xs =>
        MkDPair {_} {_} w xs ==> MkDPair {_} {\w => Unsigned w (plus k k)}
                                   (S w)
                                   (UCons {_} {_} {_} xs O)
pat k, rec =>
  halfToUnsigned {S (plus k k)} (HalfRecOdd k rec) =
    case (halfToUnsigned {k} rec) of
      pat w, xs =>
        MkDPair {_} {_} w xs ==> MkDPair {_} {\w => Unsigned w (S (plus k k))}
                                   (S w)
                                   (UCons {_} {_} {_} xs I)

natToUnsigned : (n : Nat) -> DPair Nat (\w  => Unsigned w n)
pat n =>
  natToUnsigned n = halfToUnsigned {n} (halfRec n)
-}

prfShiftLeft : (a, b : Nat) -> Equal Nat
                                     (plus (mul (pow 2 a) b)
                                           (mul (pow 2 a) b))
                                     (mul (pow 2 (S a)) b)
pat a, b =>
  prfShiftLeft a b
    = let h1 = Refl {_} {mul (pow 2 (S a)) b}
          h2 = eqInd2 {_} {_} {_} {powerPlusMulPower 2 1 a}
                 {\x => Equal Nat (mul (mul 2 (pow 2 a)) b)
                                  (mul (pow 2 (S a)) b)}
                 h1
          h3 = eqInd2 {_} {_} {_} {plusZeroRightNeutral (pow 2 a)}
                 {\x => Equal Nat (mul (plus (pow 2 a) x) b)
                                  (mul (pow 2 (S a)) b)} h2
      in eqInd2 {_} {_} {_} {mulDistributesOverPlusLeft (pow 2 a) (pow 2 a) b}
           {\x => Equal Nat x (mul (pow 2 (S a)) b)} h3

shiftLeft : (n, w : Nat) -> {val : Nat} -> < Unsigned w val > -> < Unsigned (plus n w) (mul (pow 2 n) val) >
pat w, val, xs =>
  shiftLeft Z w {val} xs = [|
    eqInd2 {_} {_} {_} {eqSym {_} {_} {_} (plusZeroRightNeutral val)} {_} ~xs
  |]
pat n, w, val, xs =>
  shiftLeft (S n) w {val} xs = [|
    let rec = ~(shiftLeft n w {val} xs)
        ans = UCons {plus n w} {mul (pow 2 n) val} {0} rec O
    in eqInd2 {_} {_} {_} {prfShiftLeft n val} {_} ans
  |]

{-
prfHalfDouble : {n : Nat} -> Half n -> Equal (Half (plus n n)) (half (plus n n)) (HalfEven n)
prfHalfDouble {Z} (HalfEven Z) = Refl {_} {_}
pat n =>
  prfHalfDouble {plus (S n) (S n)} (HalfEven (S n))
    = let rec = prfHalfDouble {S n} (half (S n))
      in Refl {_} {_}
-}
{-
Equal 
        (half (plus (S n) (S n)))
        (HalfEven (S n))
--------------------------------
Equal
       (half {(plus (plus (S n) (S n)) ((plus (S n) (S n))))}
       (HalfEven ((plus (S n) (S n))))


-}

{-
prfMultNatUWidth  : {a : Nat} -> Half (S a) ->
                    Equal Nat (S (natBits (S a)))
                              (natBits (plus (S a) (S a)))
prfMultNatUWidth {Z} (HalfOdd Z) = Refl {_} {_}
pat n =>
  prfMultNatUWidth {plus (S n) (S n)} (HalfOdd (S n)) = let rec = prfMultNatUWidth {n} (half (S n))
                                            in _

Equal Nat (S (natBits (S n)))
          (natBits (S (plus n (S n)))
--------------------------------
Equal Nat (S (natBits' {(S (S (plus n (S n))))} (half' {(S (plus n (S n)))} (half' {(plus n (S n))} (half (plus n (S n))))))) (natBits' {(S (S (plus (plus n (S n)) (S (S (plus n (S n)))))))} (half' {(S (plus (plus n (S n)) (S (S (plus n (S n))))))} (half' {(plus (plus n (S n)) (S (S (plus n (S n)))))} (half (plus (plus n (S n)) (S (S (plus n (S n)))))))))



(Equal Nat (S (natBits' {(S a)}
           (natBits' {(S (plus a (S a)))} 
--------------------------------
(Equal Nat (S (natBits' {(S (S a))})
           (natBits' {(S (S (plus a (S (S a)))))}





prfMultNatUEmpty : (c : Nat) -> Equal Nat 0 (natBits (mul c (bitsMax 0)))
pat c =>
  prfMultNatUEmpty c = let h1 = Refl {_} {natBits (mul c (bitsMax 0))}
                       in eqInd2 {_} {_} {_} {mulZeroRightZero c}
                            {\x => Equal Nat (natBits x) (natBits (mul c (bitsMax 0)))} h1
-}

{-
multNatU : (w : Nat) -> {c,val : Nat} -> HalfRec c -> < Unsigned w val > ->
           < Unsigned (plus (natBits c) w) (mul c val) >
pat w, val, xs =>
  multNatU w {0} {val} HalfRecZ xs = [| zerosU w |]
pat w, val, xs, hrec =>
  multNatU w {0} {val} (HalfRecEven 0 hrec) xs = [| zerosU w |]
pat w, val, xs, k, hrec =>
  multNatU w {plus (S k) (S k)} {val} (HalfRecEven (S k) hrec) xs
  = [| let rec = ~(multNatU w {(S k)} {val} hrec xs)
           ans = ~(shiftLeft 1 _ {_} [| rec |])
       in _
    |]
pat w, val, xs, k, hrec =>
  multNatU w {_} {val} (HalfRecOdd k hrec) xs = _
-}

extend : (w', w : Nat) -> {val : Nat} ->
         < Unsigned w val > ->
         < Unsigned (plus w' w) val >
pat w, val, xs =>
  extend Z w {val} xs = xs
pat w' =>
  extend (S w') Z {0} [| UNil |]
    = let ans = extend w' 1 {_} [| UCons {_} {_} {_} UNil O |]
      in eqInd2 {_} {_} {_} {eqSym {_} {_} {_} (plusSuccRightSucc w' 0)}
           {\h => <Unsigned h 0>} ans
pat w', w, val, xsval, xval, xs, x =>
  extend (S w') (S w) {_} [| UCons {w} {xsval} {xval} xs x |]
    = [| let rec = ~( eqInd2 {_} {_} {_} {plusSuccRightSucc w' w}
                        {\h => <Unsigned h xsval>}
                        (extend (S w') w {xsval} [|xs|])
                    )
         in UCons {_} {_} {_} rec x
      |]

prfMultConstUOdd : (n, val : Nat) ->
                   Equal Nat (plus (plus (mul n val) (plus (mul n val) 0)) val)
                             (mul (S (plus n n)) val)
pat n val =>
  prfMultConstUOdd n val
    = let h1 = Refl {_} {plus (plus (mul n val) (plus (mul n val) 0)) val}
          h2 = eqInd2 {_} {_} {_} {plusZeroRightNeutral (mul n val)}
                 {\h => Equal Nat (plus (plus (mul n val) (plus (mul n val) 0)) val)
                                  (plus (plus (mul n val) h                   ) val)}
                 h1
          h3 = eqInd2 {_} {_} {_} {eqSym {_} {_} {_} (mulDistributesOverPlusLeft n n val)}
                 {\h => Equal Nat (plus (plus (mul n val) (plus (mul n val) 0)) val)
                                  (plus h val)}
                 h2
          h4 = eqInd2 {_} {_} {_} {plusCommutative (mul (plus n n) val) val}
                 {\h => Equal Nat (plus (plus (mul n val) (plus (mul n val) 0)) val)
                                  h}
                 h3
      in h4

mulConstBits : Nat -> Nat -> Nat
mulConstBits Z _ = Z
pat n =>
  mulConstBits (S n) Z = Z
pat n, w =>
  mulConstBits (S n) (S w) = plus (clog2 (S n)) (S w)

mulCBZeroLeftZero : (c : Nat) -> Equal Nat (mulConstBits c 0) 0
mulCBZeroLeftZero Z = Refl {_} {_}
pat w =>
  mulCBZeroLeftZero (S w) = Refl {_} {_}

prfMultConstUEvenW : (n, w : Nat) -> Equal Nat (S (mulConstBits (S n) (S w)))
                                               (mulConstBits (plus (S n) (S n)) (S w))
pat n, w =>
  prfMultConstUEvenW n w
    = let h1 = Refl {_} {plus (clog2 (double (S (n)))) (S w)}
          h2 : Equal Nat (plus (S (clog2 (S (n)))) (S w))
                         (plus (clog2 (double (S (n)))) (S w)) 
             = eqInd2 {_} {_} {_} {clog2DoublePlus1 (S (n)) (SIsNonZero (n))}
                 {\h => Equal Nat (plus h (S w))
                                  (plus (clog2 (double (S (n)))) (S w))
                 } h1
      in h2

shrinkU : (n, w : Nat) -> {val : Nat} ->
          <Unsigned (S w) val> -> -- ^ Witness that val fits in an Unsigned (S w)
          <Unsigned (plus (S (clog2 (plus (S n) (S n)))) (S w))
                    (plus val (mul (plus (S n) (S n)) val))> ->
          <Unsigned (plus (clog2 (S (plus (S n) (S n)))) (S w))
                    (plus val (mul (plus (S n) (S n)) val))>
pat w, val, xIn, xOut =>
  shrinkU Z w {val} xIn xOut = xOut
pat n, w, val, xIn, xOut =>
  shrinkU (S n) w {val} xIn xOut = _

{-
xOut:_0 <(Unsigned (S (S (plus (flog2 (S (plus n (S (S n))))) (S w)))) (plus val (plus val (plus val (mul (plus n (S (S n))) val)))))>
--------------------------------
<(Unsigned (S (S (plus (flog2 (S (divCase (minus (plus n (S (S n))) 0)
                                          1
                                          (lte (minus (plus n (S (S n))) 0) 1) )))
                       (S w))))

plus (S (clog2 (plus (S (S n)) (S (S n))))) (S w)
---
plus (clog2 (S (plus (S (S n)) (S (S n))))) (S w)

-}

-- Specialised addition of a number and a scaled version of itself.
-- Handles conditional bit growth depending on 2^n boundaries.
addScaledU : (n, w : Nat) -> {val : Nat} ->
             <Unsigned (plus (clog2 (plus (S n) (S n))) (S w))
                       (mul (plus (S n) (S n)) val)> ->
             <Unsigned (S w) val> ->
             <Unsigned (plus (clog2 (S (plus (S n) (S n)))) (S w))
                       (plus val (mul (plus (S n) (S n)) val))>
pat n, w, val, rec, xs =>
  addScaledU n w {val} rec xs
    = let xsPad = extend (clog2 (plus (S n) (S n))) (S w) {_} xs
          fullAns = addU _ {_} {_} {0} xsPad rec [|O|]
      in shrinkU _ _ {_} xs fullAns


multConstU' : (w : Nat) -> {cval, val : Nat} ->
             HalfRec cval ->
             < Unsigned w val > ->
             < Unsigned (mulConstBits cval w) (mul cval val) >
pat w, val, xs =>
  multConstU' w {Z} {val} HalfRecZ xs = [| UNil |]
pat cval, hr =>
  multConstU' Z {cval} {Z} hr [| UNil |]
    = let h1 = eqInd2 {_} {_} {_} {eqSym {_} {_} {_} (mulCBZeroLeftZero cval)}
                 {\h => <Unsigned h 0>}
                 [| UNil |]
      in eqInd2 {_} {_} {_} {eqSym {_} {_} {_} (mulZeroRightZero cval)}
                 {\h => <Unsigned (mulConstBits cval 0) h>} h1
pat n, w, val, xs, hrec =>
  multConstU' (S w) {plus (S n) (S n)} {val} (HalfRecEven n hrec) xs
    = let rec = multConstU' (S w) {S n} {val} hrec xs
          ans = [| UCons {mulConstBits (S n) (S w)} {mul (S n) val} {0} ~rec O |]
          h1 = eqInd2 {_} {_} {_}
                 {eqSym {_} {_} {_} (mulDistributesOverPlusLeft (S n) (S n) val)}
                 {\h : Nat => <Unsigned (S (plus (clog2 (S n)) (S w))) h>}
                 ans
          h2 = eqInd2 {_} {_} {_} {prfMultConstUEvenW n w}
                 {\h => <Unsigned h (mul (plus (S n) (S n)) val)>}
                 h1
      in h2
pat w, val, xs, hrec =>
  multConstU' (S w) {1} {val} (HalfRecOdd Z hrec) xs
    = eqInd2 {_} {_} {_} {eqSym {_} {_} {_} (plusZeroRightNeutral val)}
        {\h => <Unsigned (S w) h>} xs
pat n, w, val, xs, hrec =>
  multConstU' (S w) {S (plus (S n) (S n))} {val} (HalfRecOdd (S n) hrec) xs
    = let rec = multConstU' (S w) {S n} {val} hrec xs
          recDouble = [| UCons {mulConstBits (S n) (S w)} {mul (S n) val} {0} ~rec O |]
          recDouble' = eqInd2 {_} {_} {_}
                 {eqSym {_} {_} {_} (mulDistributesOverPlusLeft (S n) (S n) val)}
                 {\h : Nat => <Unsigned (S (plus (clog2 (S n)) (S w))) h>}
                 recDouble
          recDouble'' = eqInd2 {_} {_} {_} {prfMultConstUEvenW n w}
                 {\h => <Unsigned h (mul (plus (S n) (S n)) val)>}
                 recDouble'
      in addScaledU n w {val} recDouble'' xs
{-
pat n, w, val, xs, hrec =>
  multConstU' (S w) {S (plus n n)} {val} (HalfRecOdd n hrec) xs
    = case multConstU' (S w) {n} {val} hrec xs of
           pat w' : Nat, rec =>
             MkDPair {_} {\a:Nat=> <Unsigned a _>} w' rec ==>
               let w'' = max (S w') (S w)
                   recPad = extend (minus (max (S w') (S w)) (S w')) (S w') {_}
                              (shiftLeft 1 _ {mul n val} rec)
                   xsPad = extend (minus (max (S w') (S w)) (S w)) (S w) {_} xs
                   recPad' = eqInd2 {_} {_} {_} {plusMinusLTE (max (S w') (S w)) (S w') (maxLeftImpliesLTE (S w') (S w))}
                               {\h => <Unsigned h (plus (mul n val) (plus (mul n val) 0)) >} recPad
                   xsPad' = eqInd2 {_} {_} {_} {plusMinusLTE (max (S w') (S w)) (S w) (maxRightImpliesLTE (S w') (S w))}
                               {\h => <Unsigned h val>} xsPad
                   ans = addU _ {_} {_} {0} recPad' xsPad' [|O|]
               in MkDPair {_} {\w=> <Unsigned w (mul (S (plus n n)) val)>}
                    (S (S (max w' w)))
                    (eqInd2 {_} {_} {_} {prfMultConstUOdd n val}
                       {\h => < Unsigned (S (S (max w' w))) h >} ans)
-}