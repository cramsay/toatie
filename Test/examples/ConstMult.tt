import Data.Bool
import Data.Nat
import Data.Unsigned

lte : Nat -> Nat -> Bool
pat right =>
  lte Z right = True
pat left =>
  lte left Z = False
pat left, right =>
  lte (S left) (S right) = lte left right

minus : Nat -> Nat -> Nat
pat right =>
  minus Z right = Z
pat left =>
  minus left Z = left
pat left, right =>
  minus (S left) (S right) = minus left right

data LTE  : (n, m : Nat) -> Type where
  LTEZero : {right : Nat} -> LTE Z right
  LTESucc : {left, right : Nat} -> LTE left right -> LTE (S left) (S right)

minusZeroRight : (left : Nat) -> Equal Nat (minus left 0) left
minusZeroRight Z = Refl {_} {_}
pat n =>
  minusZeroRight (S n) = Refl {_} {_}

plusMinusLTE : (x, y : Nat) -> LTE y x -> Equal Nat (plus (minus x y) y) x
pat x, lte =>
  plusMinusLTE x Z lte
    = let h1 = eqInd2 {_} {_} {_} {minusZeroRight x}
                 {\h => Equal Nat (plus (minus x 0) 0) (plus h 0)}
                 (Refl {_} {_})
      in eqInd2 {_} {_} {_} {plusZeroRightNeutral x}
           {_} h1
pat y =>
  plusMinusLTE Z (S y) (LTEZero {_}) impossible
pat y =>
  plusMinusLTE Z (S y) (LTESucc {y} {_} _) impossible
pat x, y, lte : LTE y x =>
  plusMinusLTE (S x) (S y) (LTESucc {y} {x} lte)
    = let h0 = plusMinusLTE x y lte
          h1 = eqCong {_} {_} {S} {_} {_} h0
          h2 = eqInd2 {_} {_} {_} {plusSuccRightSucc (minus x y) y}
                 {\h => Equal Nat h (S x) }
                 h1
      in h2

maxZeroRightNeutral : (n : Nat) -> Equal Nat (max n 0) n
maxZeroRightNeutral Z = Refl {_} {_}
pat n =>
  maxZeroRightNeutral (S n) = Refl {_} {_}

maxZeroLeftNeutral : (n : Nat) -> Equal Nat (max 0 n) n
maxZeroLeftNeutral Z = Refl {_} {_}
pat n =>
  maxZeroLeftNeutral (S n) = Refl {_} {_}

maxLeftImpliesLTE : (x, y : Nat) -> LTE x (max x y)
maxLeftImpliesLTE Z Z = LTEZero {Z}
pat x =>
  maxLeftImpliesLTE (S x) Z = LTESucc {x} {x} (
                                eqInd2 {_} {_} {_} {maxZeroRightNeutral x} {_}
                                  (maxLeftImpliesLTE x Z))
pat y =>
  maxLeftImpliesLTE Z y = LTEZero {y}
pat x, y =>
  maxLeftImpliesLTE (S x) (S y) = LTESucc {x} {max x y} (maxLeftImpliesLTE x y)

maxRightImpliesLTE : (x, y : Nat) -> LTE y (max x y)
maxRightImpliesLTE Z Z = LTEZero {Z}
pat y =>
  maxRightImpliesLTE Z (S y) = LTESucc {y} {y} (
                                eqInd2 {_} {_} {_} {maxZeroLeftNeutral y} {_}
                                  (maxRightImpliesLTE Z y))
pat x =>
  maxRightImpliesLTE x Z = LTEZero {max x Z}
pat x, y =>
  maxRightImpliesLTE (S x) (S y) = LTESucc {y} {max x y} (maxRightImpliesLTE x y)

data NonZero : Nat -> Type where
  SIsNonZero : (x : Nat) -> NonZero (S x)

-- mod' fuel a b = a `mod` (S b)
-- assuming we have enough fuel
mod' : Nat -> Nat -> Nat -> Nat
pat centre, right =>
  mod' Z centre right = centre
pat fuel, centre, right =>
  mod' (S fuel) centre right =
    case lte centre right of
      True  ==> centre
      False ==> mod' fuel (minus centre (S right)) right

modNatNZ : Nat -> (y : Nat) -> NonZero y -> Nat
pat left, right =>
  modNatNZ left (S right) (SIsNonZero right) = mod' left left right

-- div' fuel a b = a `div` (S b)
-- assuming we have enough fuel
div' : Nat -> Nat -> Nat -> Nat
pat centre, right =>
  div' Z centre right = Z
pat fuel, centre, right =>
  div' (S fuel) centre right =
    case lte centre right of
      True  ==> Z
      False ==> S (div' fuel (minus centre (S right)) right)

divNatNZ : Nat -> (y : Nat) -> NonZero y -> Nat
pat left, right =>
  divNatNZ left (S right) (SIsNonZero right) = div' left left right

flog2 : Nat -> Nat
flog2 Z = Z
flog2 1 = Z
pat n =>
  flog2 n = plus 1 (flog2 (divNatNZ n 2 (SIsNonZero 1)))

clog2 : Nat -> Nat
clog2 Z = Z
pat n =>
  clog2 (S n) = S (flog2 n)

zerosU : (w : Nat) -> Unsigned w 0
zerosU Z = UNil
pat w =>
  zerosU (S w) = UCons {_} {_} {_} (zerosU w) O























-- Dependent Pair
data DPair : (a : Type) -> (P : a -> Type) -> Type where
  MkDPair : {a : Type} -> {P : a -> Type} -> (x : a) -> (pf : P x) -> DPair a P

-- View for dividing a Nat in half
data Half : Nat -> Type where
     HalfOdd : (n : Nat) -> Half (S (plus n n))
     HalfEven : (n : Nat) -> Half (plus n n)

-- View for recursively dividing a Nat in half
data HalfRec : Nat -> Type where
     HalfRecZ : HalfRec Z
     HalfRecEven : (n : Nat) -> HalfRec n -> HalfRec (plus n n)
     HalfRecOdd  : (n : Nat) -> HalfRec n -> HalfRec (S (plus n n))

-- We don't have heuristics to ensure we match on the `Half` arg before our Nat
-- Instead, we encourage toatie to match on the `Half` by introducing `n` as implicit
half' :  {n : Nat} -> Half n -> Half (S n)
pat k =>
  half' {S (plus k k)} (HalfOdd k)
    = eqInd2 {_} {_} {_} {eqSym {_} {_} {_} (plusSuccRightSucc (S k) k)} {_}
        (HalfEven (S k))
pat k =>
  half' {plus k k} (HalfEven k) = HalfOdd k

half :  (n : Nat) -> Half n
half Z = HalfEven Z
pat n =>
  half (S n) = half' {n} (half n)

halfRec :  (n : Nat) -> HalfRec n
halfRec' :  {n : Nat} -> Half n -> HalfRec (S n)

pat k =>
  halfRec' {plus k k} (HalfEven k) = HalfRecOdd _ (halfRec k)
pat k =>
  halfRec' {S (plus k k)} (HalfOdd k)
    = eqInd2 {_} {_} {_} {eqSym {_} {_} {_} (plusSuccRightSucc (S k) k)} {_}
        (HalfRecEven (S k) (halfRec (S k)))

halfRec Z = HalfRecZ
pat n =>
  halfRec (S n) = halfRec' {n} (half n)

natBits' : {n : Nat} -> Half n -> Nat
natBits' {_} (HalfEven 0) = 0
pat k =>
  natBits' {_} (HalfEven (S k)) = S (natBits' {S k} (half (S k)))
pat k =>
  natBits' {_} (HalfOdd k) = S (natBits' {k} (half k))

natBits : Nat -> Nat
pat n =>
  natBits n = natBits' {n} (half n)

bitsMax : Nat -> Nat
pat b =>
  bitsMax b = minus (pow 2 b) 1

halfToUnsigned : {n : Nat} -> HalfRec n -> DPair Nat (\w  => Unsigned w n)
halfToUnsigned {Z} HalfRecZ = MkDPair {_} {\w => Unsigned w Z} Z UNil
pat k, rec =>
  halfToUnsigned {plus k k} (HalfRecEven k rec) =
    case (halfToUnsigned {k} rec) of
      pat w, xs =>
        MkDPair {_} {_} w xs ==> MkDPair {_} {\w => Unsigned w (plus k k)}
                                   (S w)
                                   (UCons {_} {_} {_} xs O)
pat k, rec =>
  halfToUnsigned {S (plus k k)} (HalfRecOdd k rec) =
    case (halfToUnsigned {k} rec) of
      pat w, xs =>
        MkDPair {_} {_} w xs ==> MkDPair {_} {\w => Unsigned w (S (plus k k))}
                                   (S w)
                                   (UCons {_} {_} {_} xs I)

natToUnsigned : (n : Nat) -> DPair Nat (\w  => Unsigned w n)
pat n =>
  natToUnsigned n = halfToUnsigned {n} (halfRec n)

prfShiftLeft : (a, b : Nat) -> Equal Nat
                                     (plus (mul (pow 2 a) b)
                                           (mul (pow 2 a) b))
                                     (mul (pow 2 (S a)) b)
pat a, b =>
  prfShiftLeft a b
    = let h1 = Refl {_} {mul (pow 2 (S a)) b}
          h2 = eqInd2 {_} {_} {_} {powerPlusMulPower 2 1 a}
                 {\x => Equal Nat (mul (mul 2 (pow 2 a)) b)
                                  (mul (pow 2 (S a)) b)}
                 h1
          h3 = eqInd2 {_} {_} {_} {plusZeroRightNeutral (pow 2 a)}
                 {\x => Equal Nat (mul (plus (pow 2 a) x) b)
                                  (mul (pow 2 (S a)) b)} h2
      in eqInd2 {_} {_} {_} {mulDistributesOverPlusLeft (pow 2 a) (pow 2 a) b}
           {\x => Equal Nat x (mul (pow 2 (S a)) b)} h3

shiftLeft : (n, w : Nat) -> {val : Nat} -> < Unsigned w val > -> < Unsigned (plus n w) (mul (pow 2 n) val) >
pat w, val, xs =>
  shiftLeft Z w {val} xs = [|
    eqInd2 {_} {_} {_} {eqSym {_} {_} {_} (plusZeroRightNeutral val)} {_} ~xs
  |]
pat n, w, val, xs =>
  shiftLeft (S n) w {val} xs = [|
    let rec = ~(shiftLeft n w {val} xs)
        ans = UCons {plus n w} {mul (pow 2 n) val} {0} rec O
    in eqInd2 {_} {_} {_} {prfShiftLeft n val} {_} ans
  |]

{-
prfHalfDouble : {n : Nat} -> Half n -> Equal (Half (plus n n)) (half (plus n n)) (HalfEven n)
prfHalfDouble {Z} (HalfEven Z) = Refl {_} {_}
pat n =>
  prfHalfDouble {plus (S n) (S n)} (HalfEven (S n))
    = let rec = prfHalfDouble {S n} (half (S n))
      in Refl {_} {_}
-}
{-
Equal 
        (half (plus (S n) (S n)))
        (HalfEven (S n))
--------------------------------
Equal
       (half {(plus (plus (S n) (S n)) ((plus (S n) (S n))))}
       (HalfEven ((plus (S n) (S n))))


-}

{-
prfMultNatUWidth  : {a : Nat} -> Half (S a) ->
                    Equal Nat (S (natBits (S a)))
                              (natBits (plus (S a) (S a)))
prfMultNatUWidth {Z} (HalfOdd Z) = Refl {_} {_}
pat n =>
  prfMultNatUWidth {plus (S n) (S n)} (HalfOdd (S n)) = let rec = prfMultNatUWidth {n} (half (S n))
                                            in _

Equal Nat (S (natBits (S n)))
          (natBits (S (plus n (S n)))
--------------------------------
Equal Nat (S (natBits' {(S (S (plus n (S n))))} (half' {(S (plus n (S n)))} (half' {(plus n (S n))} (half (plus n (S n))))))) (natBits' {(S (S (plus (plus n (S n)) (S (S (plus n (S n)))))))} (half' {(S (plus (plus n (S n)) (S (S (plus n (S n))))))} (half' {(plus (plus n (S n)) (S (S (plus n (S n)))))} (half (plus (plus n (S n)) (S (S (plus n (S n)))))))))



(Equal Nat (S (natBits' {(S a)}
           (natBits' {(S (plus a (S a)))} 
--------------------------------
(Equal Nat (S (natBits' {(S (S a))})
           (natBits' {(S (S (plus a (S (S a)))))}





prfMultNatUEmpty : (c : Nat) -> Equal Nat 0 (natBits (mul c (bitsMax 0)))
pat c =>
  prfMultNatUEmpty c = let h1 = Refl {_} {natBits (mul c (bitsMax 0))}
                       in eqInd2 {_} {_} {_} {mulZeroRightZero c}
                            {\x => Equal Nat (natBits x) (natBits (mul c (bitsMax 0)))} h1
-}

{-
multNatU : (w : Nat) -> {c,val : Nat} -> HalfRec c -> < Unsigned w val > ->
           < Unsigned (plus (natBits c) w) (mul c val) >
pat w, val, xs =>
  multNatU w {0} {val} HalfRecZ xs = [| zerosU w |]
pat w, val, xs, hrec =>
  multNatU w {0} {val} (HalfRecEven 0 hrec) xs = [| zerosU w |]
pat w, val, xs, k, hrec =>
  multNatU w {plus (S k) (S k)} {val} (HalfRecEven (S k) hrec) xs
  = [| let rec = ~(multNatU w {(S k)} {val} hrec xs)
           ans = ~(shiftLeft 1 _ {_} [| rec |])
       in _
    |]
pat w, val, xs, k, hrec =>
  multNatU w {_} {val} (HalfRecOdd k hrec) xs = _
-}

extend : (w', w : Nat) -> {val : Nat} ->
         < Unsigned w val > ->
         < Unsigned (plus w' w) val >
pat w, val, xs =>
  extend Z w {val} xs = xs
pat w' =>
  extend (S w') Z {0} [| UNil |]
    = let ans = extend w' 1 {_} [| UCons {_} {_} {_} UNil O |]
      in eqInd2 {_} {_} {_} {eqSym {_} {_} {_} (plusSuccRightSucc w' 0)}
           {\h => <Unsigned h 0>} ans
pat w', w, val, xsval, xval, xs, x =>
  extend (S w') (S w) {_} [| UCons {w} {xsval} {xval} xs x |]
    = [| let rec = ~( eqInd2 {_} {_} {_} {plusSuccRightSucc w' w}
                        {\h => <Unsigned h xsval>}
                        (extend (S w') w {xsval} [|xs|])
                    )
         in UCons {_} {_} {_} rec x
      |]

prfMultConstUOdd : (n, val : Nat) ->
                   Equal Nat (plus (plus (mul n val) (plus (mul n val) 0)) val)
                             (mul (S (plus n n)) val)
pat n val =>
  prfMultConstUOdd n val
    = let h1 = Refl {_} {plus (plus (mul n val) (plus (mul n val) 0)) val}
          h2 = eqInd2 {_} {_} {_} {plusZeroRightNeutral (mul n val)}
                 {\h => Equal Nat (plus (plus (mul n val) (plus (mul n val) 0)) val)
                                  (plus (plus (mul n val) h                   ) val)}
                 h1
          h3 = eqInd2 {_} {_} {_} {eqSym {_} {_} {_} (mulDistributesOverPlusLeft n n val)}
                 {\h => Equal Nat (plus (plus (mul n val) (plus (mul n val) 0)) val)
                                  (plus h val)}
                 h2
          h4 = eqInd2 {_} {_} {_} {plusCommutative (mul (plus n n) val) val}
                 {\h => Equal Nat (plus (plus (mul n val) (plus (mul n val) 0)) val)
                                  h}
                 h3
      in h4

multConstU' : (w : Nat) -> {cval, val : Nat} ->
             HalfRec cval ->
             < Unsigned w val > ->
             DPair Nat (\w' : Nat => < Unsigned w' (mul cval val) >)
pat w, val, xs =>
  multConstU' w {Z} {val} HalfRecZ xs = MkDPair {_} {_} 0 [| UNil |]
pat cval, hr =>
  multConstU' Z {cval} {Z} hr [| UNil |] = MkDPair {_} {_} 0 [| UNil |]
--pat w, val, xs, hrec =>
--  multConstU' w {plus Z Z} {val} (HalfRecEven Z hrec) xs = MkDPair {_} {_} 0 [| UNil |]
{-
pat n, w, val, xs, hrec =>
  multConstU' (S w) {plus (S n) (S n)} {val} (HalfRecEven (S n) hrec) xs
    = case multConstU' (S w) {S n} {val} hrec xs of
           pat w' : Nat, rec =>
             MkDPair {_} {\a:Nat=> <Unsigned a _>} w' rec ==>
               let ans = [| UCons {w'} {mul (S n) val} {0} ~rec O |]
               in MkDPair {_} {\a:Nat=> <Unsigned a (mul (plus (S n) (S n)) val)>}
                    (S w')
                    (eqInd2 {_} {_} {_}
                            {eqSym {_} {_} {_} (mulDistributesOverPlusLeft (S n) (S n) val)}
                            {\h : Nat => <Unsigned (S w') h >}
                            ans
                    )
-}
pat n, w, val, xs, hrec =>
  multConstU' (S w) {plus n n} {val} (HalfRecEven n hrec) xs
    = case multConstU' (S w) {n} {val} hrec xs of
           pat w' : Nat, rec =>
             MkDPair {_} {\a:Nat=> <Unsigned a _>} w' rec ==>
               let ans = [| UCons {w'} {mul n val} {0} ~rec O |]
               in MkDPair {_} {\a:Nat=> <Unsigned a (mul (plus n n) val)>}
                    (S w')
                    (eqInd2 {_} {_} {_}
                            {eqSym {_} {_} {_} (mulDistributesOverPlusLeft n n val)}
                            {\h : Nat => <Unsigned (S w') h >}
                            ans
                    )
pat n, w, val, xs, hrec =>
  multConstU' (S w) {S (plus n n)} {val} (HalfRecOdd n hrec) xs
    = case multConstU' (S w) {n} {val} hrec xs of
           pat w' : Nat, rec =>
             MkDPair {_} {\a:Nat=> <Unsigned a _>} w' rec ==>
               let w'' = max (S w') (S w)
                   recPad = extend (minus (max (S w') (S w)) (S w')) (S w') {_}
                              (shiftLeft 1 _ {mul n val} rec)
                   xsPad = extend (minus (max (S w') (S w)) (S w)) (S w) {_} xs
                   recPad' = eqInd2 {_} {_} {_} {plusMinusLTE (max (S w') (S w)) (S w') (maxLeftImpliesLTE (S w') (S w))}
                               {\h => <Unsigned h (plus (mul n val) (plus (mul n val) 0)) >} recPad
                   xsPad' = eqInd2 {_} {_} {_} {plusMinusLTE (max (S w') (S w)) (S w) (maxRightImpliesLTE (S w') (S w))}
                               {\h => <Unsigned h val>} xsPad
                   ans = addU _ {_} {_} {0} recPad' xsPad' [|O|]
               in MkDPair {_} {\w=> <Unsigned w (mul (S (plus n n)) val)>}
                    (S (S (max w' w)))
                    (eqInd2 {_} {_} {_} {prfMultConstUOdd n val}
                       {\h => < Unsigned (S (S (max w' w))) h >} ans)

multConstU : (cval, w : Nat) -> {val : Nat} ->
             < Unsigned w val > ->
             DPair Nat (\w' : Nat => < Unsigned w' (mul cval val) >)
pat cval, val, w, xs =>
  multConstU cval w {val} xs = multConstU' w {cval} {val} (halfRec cval) xs

dSnd : (a : Type) -> (f : a -> Type) -> DPair a f -> (f a)



{-
multBy12w5 : {val : Nat} -> <Unsigned 5 val -> Unsigned 10 (mul 12 val)>
pat val =>
  multBy12w5 {val} = [| \xs => ~(
                          case multConstU 12 5 {val} [|xs|] of
                            pat ys => MkDPair {_} {\w' => <Unsigned 10 (mul 12 val)>} 10 ys ==> _
                            pat w', ys => MkDPair {_} {\w' => <Unsigned w' (mul 12 val)>} w' ys ==> _
                        )
                     |]
-}