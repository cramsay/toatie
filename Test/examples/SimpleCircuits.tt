import Data.Vect

simple Bit : Type where
  O : Bit
  I : Bit

xor : Bit -> Bit -> Bit
xor O O = O
xor O I = I
xor I O = I
xor I I = O

-- This looks good! We see that the quotes disappear and we eta-expand the xor with two arguments
circXor : <Bit -> Bit -> Bit>
circXor = [| xor |]

-- Looks good! We introduce new names for only the head and tail args
fst : Vect 2 Bit -> Bit
pat x, xs =>
  fst (VCons {Bit} {1} x xs) = x

-- Looks good!
twoNots : < Vect 2 Bit -> Vect 2 Bit >
twoNots = unrollMap 2 {_} {_} [| xor I |]

-- Do our patterns get handled OK by our case lifting?
-- Looks good!
caseTest : (n : Nat) -> Vect n Bit -> Nat
caseTest Z (VNil {_}) = 0
pat k, xs =>
  caseTest (S k) xs = case xs of
                        pat b, bs
                        => VCons {_} {_} b bs ==> plus 1 k


maybeNot : Vect 2 Bit -> Bit
pat b =>
  maybeNot [O, b] = b
pat b =>
  maybeNot [O, b] = xor I b

circMN : < Vect 2 Bit -> Bit >
circMN = [| maybeNot |] 

cGate : Bit -> Nat -> Bit -> Bit
pat a, b => cGate a Z     b = b
pat b, n => cGate O (S n) b = xor I b
pat b, n => cGate I (S n) b = xor O b

mycirc : Bit ->  Bit
mycirc = \a => cGate O 1 a

{- TODO

Why does this compile?
It's not covering.

maybeNot : Vect 2 Bit -> Bit
pat b =>
  maybeNot [O, b] = b
pat b =>
  maybeNot [O, b] = xor I b

Seems even if we write it in full, the case tree doesn't infer that the type of the scrutinee is Bit. Why's that?

maybeNot : Vect 2 Bit -> Bit
pat b =>
  maybeNot (VCons {Bit} {1} O (VCons {Bit} {0} b (VNil {Bit}))) = b
pat b =>
  maybeNot (VCons {Bit} {1} O (VCons {Bit} {0} b (VNil {Bit}))) = xor I b

-}