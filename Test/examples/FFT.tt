import Data.Nat
import Data.Nat.Inequality
import Data.Fin
import Data.Signed
import Data.Vect_ -- This version of Vect is a parameter type, so we can have types who depend on its values
import Proofs

-- A descriptions of twiddle factors that can ensure our DIT radix-2 structure is
-- equivalent to a full FFT.

data Twiddles : Nat -> Type where
  MkTwiddles : (n : Nat) ->
               (f : Nat -> Nat -> ZZ) ->
               -- ^ function to generate twiddle factors
               (prfMZeroOne : Equal ZZ (f 0 n) (Pos 1)) ->
               (prfMNOne    : Equal ZZ (f n n) (Pos 1)) ->
               (prfPow      : (k, m : Nat) -> Equal ZZ (multZ (f k n) (f m n)) (f (plus k m) n)) ->
               (prfScale    : (m, c, n' : Nat) -> Equal Nat n (mul c n') ->
                              Equal ZZ (f m n') (f (mul c m) n)) ->
               -- ^ Proofs of twiddle factor laws
               Twiddles n

squareWave : Nat -> Nat -> ZZ
pat k =>
  squareWave k 1 = Pos 1
pat n =>
  squareWave Z n = (Pos 1)
pat n =>
  squareWave (S Z) n = (NegS 0) 
pat n, k =>
  squareWave (S (S k)) n = squareWave k n

lemmaTw2NegIsSuccM : (m : Nat) -> Equal ZZ (multZ (NegS 0) (squareWave m 2)) (squareWave (S m) 2)
lemmaTw2NegIsSuccM Z = Refl {_} {_}
lemmaTw2NegIsSuccM 1 = Refl {_} {_}
pat m =>
  lemmaTw2NegIsSuccM (S (S m)) = lemmaTw2NegIsSuccM m

prfTw2Pow : (k, m : Nat) -> Equal ZZ (multZ (squareWave k 2) (squareWave m 2)) (squareWave (plus k m) 2)
pat m =>
  prfTw2Pow Z m
    = eqInd2 {_} {_} {_} {multOneLeftNeutralZ (squareWave m 2)}
        {\h => Equal ZZ (multZ (Pos 1) (squareWave m 2)) h}
        (Refl {_} {_})
pat m =>
  prfTw2Pow 1 m
    = lemmaTw2NegIsSuccM m
pat k,m =>
  prfTw2Pow (S (S k)) m
    = prfTw2Pow k m

lemmaTw2EvenPos1 : (m : Nat) -> Equal ZZ (squareWave (mul 2 m) 2) (Pos 1)
lemmaTw2EvenPos1 Z = Refl {_} {_}
lemmaTw2EvenPos1 1 = Refl {_} {_}
pat m =>
  lemmaTw2EvenPos1 (S (S m))
    = let h1 = eqInd2 {_} {_} {_} {eqSym {_} {_} {_} (plusSuccRightSucc m (plus (S m) 0))}
                 {\h => Equal ZZ (squareWave (plus m (plus (S (S m)) 0)) 2) (squareWave h 2)}
                 (Refl {_} {_})
      in eqInd2 {_} {_} {_} {lemmaTw2EvenPos1 (S m)}
           {\h => Equal ZZ (squareWave (plus m (plus (S (S m)) 0)) 2) h}
           h1
   

prfTw2Scale : (m,c,n' : Nat) ->
              Equal Nat 2 (mul c n') ->
              Equal ZZ (squareWave m n') (squareWave (mul c m) 2)
pat m, n' =>
  prfTw2Scale m Z n' (Refl {_} {_}) impossible
pat m, c =>
  prfTw2Scale m c Z (Refl {_} {0}) impossible
pat m, prf =>
  prfTw2Scale m 2 1 prf = eqSym {_} {_} {_} (lemmaTw2EvenPos1 m)
pat m, prf =>
  prfTw2Scale m 1 2 prf = eqInd2 {_} {_} {_} {plusZeroRightNeutral m}
                            {\h => Equal ZZ (squareWave h 2) (squareWave (plus m 0) 2)}
                            (Refl {_} {_})

twiddlesN2 : Twiddles 2
twiddlesN2 = let h1 = 0
             in MkTwiddles 2 squareWave (Refl {_} {_}) (Refl {_} {_}) prfTw2Pow prfTw2Scale

-- Prove that we can always half N in our twiddle factors to get a new set of factors

doubleM : (f : Nat -> Nat -> ZZ) -> Nat -> Nat -> ZZ
pat f m n =>
  doubleM f m n = f (plus m m) n

lemmaTwDouble : (f : Nat -> Nat -> ZZ) ->
                (n, m, n' : Nat) -> Equal Nat n (plus n' n') ->
                (prfScale :
                   (m, c, n' : Nat) -> Equal Nat n (mul c n') ->
                                       Equal ZZ (f m n') (f (mul c m) n)) ->
                Equal ZZ (f m n') (f (plus m m) n)
pat f, n, m, n', prfN, p4 =>
  lemmaTwDouble f n m n' prfN p4
    = let prfN' = eqInd2 {_} {_} {_} {eqSym {_} {_} {_} (plusZeroRightNeutral n')}
                    {\h => Equal Nat n (plus n' h)} prfN
          h1 = p4 m 2 n' prfN'
      in eqInd2 {_} {_} {_} {plusZeroRightNeutral m}
           {\h => Equal ZZ (f m n') (f (plus m h) n)} h1

lemmaHalfP4 : (f : Nat -> Nat -> ZZ) ->
              (n, m, c, n' : Nat) ->
              (p4 : (m : Nat) -> ((c : Nat) -> ((n' : Nat) -> ((Equal Nat (S (plus n (S n))) (mul c n'))) ->
                    (Equal ZZ (f m n') (f (mul c m) (S (plus n (S n)))))))) ->
              Equal Nat (S n) (mul c n') ->
              Equal ZZ (f (plus m m) n') (f (plus (mul c m) (mul c m)) (S n))
pat f, n, m, c, n', p4, prf =>
  lemmaHalfP4 f n m c n' p4 prf
    = let prfN : Equal Nat (plus (S n) (S n)) (mul (plus c c) n')
               = eqInd2 {_} {_} {_} {eqSym {_} {_} {_} (mulDistributesOverPlusLeft c c n')}
                   {\h => Equal Nat (plus (S n) (S n)) h}
                   (eqCong {_} {_} {\a => plus a a} {_} {_} prf)
          p4H = p4 (plus m m) (plus c c) n' prfN
          p4H1 = eqInd2 {_} {_} {_} {mulDistributesOverPlusRight (plus c c) m m}
                   {\h => Equal ZZ (f (plus m m) n')
                                    (f h (plus (S n) (S n)))}
                   p4H
          p4H2 = eqInd2 {_} {_} {_} {mulDistributesOverPlusLeft c c m}
                   {\h => Equal ZZ (f (plus m m) n')
                                    (f (plus h h) (plus (S n) (S n)))}
                   p4H1
          p4' = eqInd2 {_} {_} {_} {eqSym {_} {_} {_}
                  (lemmaTwDouble f (plus (S n) (S n)) (plus (mul c m) (mul c m)) (S n) (Refl {_} {_}) p4)}
                  {\h => Equal ZZ (f (plus m m) n') h} p4H2
      in p4'

halfTwiddles : {n : Nat} -> Twiddles (plus n n) -> Twiddles n
pat f, p1, p2, p3, p4 =>
  halfTwiddles {Z} (MkTwiddles Z f p1 p2 p3 p4) = (MkTwiddles Z f p1 p2 p3 p4)
pat n, f, p1, p2, p3, p4 =>
  halfTwiddles {S n} (MkTwiddles (plus (S n) (S n)) f p1 p2 p3 p4)
    = let p1' = eqInd2 {_} {_} {_} {eqSym {_} {_} {_}
                                      (lemmaTwDouble f (plus (S n) (S n)) 0 (S n) (Refl {_} {_}) p4)}
                  {\h => Equal ZZ h (Pos 1)} p1
          -- For new p2, show f (plus (S n) (S n)) (S n)) = (Pos 1)
          p2h1 = eqSym {_} {_} {_} (p3 (plus (S n) (S n)) (plus (S n) (S n)))
          p2h2 : Equal ZZ (doubleM f (plus (S n) (S n)) (plus (S n) (S n))) (Pos 1)
               = eqInd2 {_} {_} {_} {p2}
                   {\h => Equal ZZ (doubleM f (plus (S n) (S n)) (plus (S n) (S n)))
                                   (multZ h h)
                   } p2h1
          p2' = eqInd2 {_} {_} {_} {eqSym {_} {_} {_}
                                      (lemmaTwDouble f (plus (S n) (S n)) (plus (S n) (S n)) (S n) (Refl {_} {_}) p4)}
                  {\h => Equal ZZ h (Pos 1)} p2h2
          -- For new p3, show f (k + k) (S n) * f (m + m) (S n) = f ((k + m) + (k + m)) (S n)
          p3h1 = \k => \m => p3 (plus (plus k k) (plus k k)) (plus (plus m m) (plus m m))
          p3h2 = \k => \m => eqInd2 {_} {_} {_} {plusPlusAssociative (plus k k) (plus k k) (plus m m) (plus m m)}
                               {\h => Equal ZZ (multZ (doubleM f (plus k k) (plus (S n) (S n)))
                                                      (doubleM f (plus m m) (plus (S n) (S n))))
                                               (f h (plus (S n) (S n)))
                               } (p3h1 k m)
          p3h3 = \k => \m => eqInd2 {_} {_} {_} {eqSym {_} {_} {_} 
                                                   (lemmaTwDouble f (plus (S n) (S n)) (plus k k) (S n) (Refl {_} {_}) p4)}
                   {\h => Equal ZZ (multZ h
                                          (doubleM f (plus m m) (plus (S n) (S n))))
                                   (f (plus (plus (plus k k) (plus m m)) (plus (plus k k) (plus m m))) (plus (S n) (S n)))
                   } (p3h2 k m)
          p3h4 = \k => \m => eqInd2 {_} {_} {_} {eqSym {_} {_} {_}
                                                   (lemmaTwDouble f (plus (S n) (S n)) (plus m m) (S n) (Refl {_} {_}) p4)}
                   {\h => Equal ZZ (multZ (f (plus k k) (S n))
                                          h)
                                   (f (plus (plus (plus k k) (plus m m)) (plus (plus k k) (plus m m))) (plus (S n) (S n)))
                   } (p3h3 k m)
          p3h5 = \k => \m => eqInd2 {_} {_} {_} {eqSym {_} {_} {_} 
                                                   (lemmaTwDouble f (plus (S n) (S n)) (plus (plus k k) (plus m m)) (S n)
                                                                  (Refl {_} {_}) p4)}
                   {\h => Equal ZZ (multZ (f (plus k k) (S n))
                                          (f (plus m m) (S n)))
                                   h
                   } (p3h4 k m)
          p3' = \k => \m => eqInd2 {_} {_} {_} {plusPlusAssociative k k m m}
                  {\h => Equal ZZ (multZ (f (plus k k) (S n))
                                         (f (plus m m) (S n)))
                                  (f h (S n))
                  } (p3h5 k m)
      in MkTwiddles (S n) (doubleM f) p1' p2' p3' (\m => \c => \n' => lemmaHalfP4 f n m c n' p4)

-- Generate a row of twiddle factors
-- Returns w^(k m')_n for all m' <- [0 .. m-1]

twiddleRow : (k, m, n : Nat) -> Twiddles n -> Vect m ZZ
pat k, m, n, f, p1, p2, p3, p4 =>
  twiddleRow k m n (MkTwiddles n f p1 p2 p3 p4)
    = map m {_} {_} (\i => f (mul k (finToNat {m} i)) n) (indices m)

-- Witness that a `Nat` is a power of two
data Pow2 : Nat -> Type where
  POne : Pow2 1
  PDouble : (n : Nat) -> Pow2 n -> Pow2 (plus n n)

-- Let's describe the plain, mathematical DFT equation to direct our optimised structure's type
-- See first eqn @ https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm#The_radix-2_DIT_case

dftK : (n : Nat) -> (Fin n) -> Twiddles n -> Vect n ZZ -> ZZ
pat n, k, tw, xs =>
  dftK n k tw xs
    = let mults = zipWith n {_} {_} {_} multZ (twiddleRow (finToNat {n} k) n n tw) xs
      in sumZ n mults

dft : (n : Nat) -> Twiddles n -> Vect n ZZ -> Vect n ZZ
pat n, tw, xs =>
  dft n tw xs
    = imap n {_} {_}
           (\i => \x => dftK n i tw xs)
           xs

-- Let's see if we can make a non-synthesisable dit description and prove its equivalence

dit : {n : Nat} -> Twiddles n -> Pow2 n -> Vect n ZZ -> Vect n ZZ

-- Helper for split inputs (helps with our proofs a little bit to be able to refer to this by name)
dit' : (n : Nat) -> Twiddles (plus n n) -> Pow2 n -> Vect 2 (Vect n ZZ) -> Vect (plus n n) ZZ
pat n, tw, prec, es, os =>
  dit' n tw prec [es, os]
    = let halfTw = halfTwiddles {n} tw
          -- Recurse on evens
          es' = dit {n} halfTw prec es
          -- Recurse on odds
          os' = dit {n} halfTw prec os
          -- Get odds, multipied by twiddles
          tws = twiddleRow 1 n (plus n n) tw
          os'' = zipWith n {_} {_} {_} multZ tws os' -- ^ For our circuit, we should use
                                                     -- our signed constant nat mult fn but
                                                     -- subtract when or twiddle's negative
          -- Append evens + odds and evens - odds
          outEs = zipWith n {_} {_} {_} plusZ es' os''
          outOs = zipWith n {_} {_} {_} subZ  es' os''
          outs = append {_} {_} {_} outEs outOs
      in outs

pat tw, xs =>
  dit {1} tw POne xs = xs
pat n, tw, prec, xs =>
  dit {plus n n} tw (PDouble n prec) xs
    = dit' n tw prec (deinterleave n {_} xs)

-- Prove our DIT's base case is equivalent to a 1-input DFT

eqDitBase : (tw : Twiddles 1) -> (xs : Vect 1 ZZ) -> Equal (Vect 1 ZZ) (dft 1 tw xs) (dit {1} tw POne xs)
pat f, p1, p2, p3, p4, k, x =>
  eqDitBase (MkTwiddles 1 f p1 p2 p3 p4) [x]
    = let h1 = eqInd2 {_} {_} {_} {p1}
                 {\h => Equal (Vect 1 ZZ)
                                 [multZ (f 0 1) x]
                                 [multZ h x]
                 } (Refl {_} {_})
          h2 = eqInd2 {_} {_} {_} {multOneLeftNeutralZ x}
                 {\h => Equal (Vect 1 ZZ)
                                 [multZ (f 0 1) x]
                                 [h]
                 } h1
      in h2

-- ...And the recursive case

lemmaTwiddleRowElem :
  (n, k : Nat) -> (m : Fin n) ->
  ---------------------- Twiddle factor defs
  (f : Nat -> Nat -> ZZ) ->
  (p1 : Equal ZZ (f 0 n) (Pos 1)) ->
  (p2 : Equal ZZ (f n n) (Pos 1)) ->
  (p3 : (k, m : Nat) -> Equal ZZ (multZ (f k n) (f m n)) (f (plus k m) n)) ->
  (p4 : (m, c, n' : Nat) -> Equal Nat n (mul c n') ->
        Equal ZZ (f m n') (f (mul c m) n)) ->
  ----------------------
  Equal ZZ (at {_} {_} m (twiddleRow k n n (MkTwiddles n f p1 p2 p3 p4)))
           (f (mul k (finToNat {n} m)) n)
pat n, k, m, f, p1, p2, p3, p4 =>
  lemmaTwiddleRowElem n k m f p1 p2 p3 p4
    = let h1 = eqInd2 {_} {_} {_} {atCommutesMap n {_} {_} m (\i => f (mul k (finToNat {n} i)) n) (indices n)}
                 {\h => Equal ZZ (at {_} {_} m (twiddleRow k n n (MkTwiddles n f p1 p2 p3 p4)))
                                 h}
                 (Refl {_} {_})
          h2 = eqInd2 {_} {_} {_} {atIndicesNeutral n m}
                 {\h => Equal ZZ (at {_} {_} m (twiddleRow k n n (MkTwiddles n f p1 p2 p3 p4)))
                                 (f (mul k (finToNat {n} h)) n)}
                 h1
      in h2

lemmaTwiddleHalfRowElem :
  (n, k : Nat) -> (m : Fin n) ->
  ---------------------- Twiddle factor defs
  (f : Nat -> Nat -> ZZ) ->
  (p1 : Equal ZZ (f 0 (plus n n)) (Pos 1)) ->
  (p2 : Equal ZZ (f (plus n n) (plus n n)) (Pos 1)) ->
  (p3 : (k, m : Nat) -> Equal ZZ (multZ (f k (plus n n)) (f m (plus n n))) (f (plus k m) (plus n n))) ->
  (p4 : (m, c, n' : Nat) -> Equal Nat (plus n n) (mul c n') ->
        Equal ZZ (f m n') (f (mul c m) (plus n n))) ->
  ----------------------
  Equal ZZ (at {_} {_} m (twiddleRow k n (plus n n) (MkTwiddles (plus n n) f p1 p2 p3 p4)))
           (f (mul k (finToNat {n} m)) (plus n n))
pat n, k, m, f, p1, p2, p3, p4 =>
  lemmaTwiddleHalfRowElem n k m f p1 p2 p3 p4
    = let h1 = eqInd2 {_} {_} {_} {atCommutesMap n {_} {_} m (\i => f (mul k (finToNat {n} i)) (plus n n)) (indices n)}
                 {\h => Equal ZZ (at {_} {_} m (twiddleRow k n (plus n n) (MkTwiddles (plus n n) f p1 p2 p3 p4)))
                                 h}
                 (Refl {_} {_})
          h2 = eqInd2 {_} {_} {_} {atIndicesNeutral n m}
                 {\h => Equal ZZ (at {_} {_} m (twiddleRow k n (plus n n) (MkTwiddles (plus n n) f p1 p2 p3 p4)))
                                 (f (mul k (finToNat {n} h)) (plus n n))}
                 h1
      in h2

lemmaHalfTwiddleDoublesM :
  (n : Nat) ->
  NonZero n ->
  ---------------------- Big twiddle factor defs
  (f : Nat -> Nat -> ZZ) ->
  (p1 : Equal ZZ (f 0 (plus n n)) (Pos 1)) ->
  (p2 : Equal ZZ (f (plus n n) (plus n n)) (Pos 1)) ->
  (p3 : (k, m : Nat) -> Equal ZZ (multZ (f k (plus n n)) (f m (plus n n))) (f (plus k m) (plus n n))) ->
  (p4 : (m, c, n' : Nat) -> Equal Nat (plus n n) (mul c n') ->
        Equal ZZ (f m n') (f (mul c m) (plus n n))) ->
  ---------------------- Half twiddle factor defs
  (f' : Nat -> Nat -> ZZ) ->
  (p1' : Equal ZZ (f' 0 n) (Pos 1)) ->
  (p2' : Equal ZZ (f' n n) (Pos 1)) ->
  (p3' : (k, m : Nat) -> Equal ZZ (multZ (f' k n) (f' m n)) (f' (plus k m) n)) ->
  (p4' : (m, c, n' : Nat) -> Equal Nat n (mul c n') ->
         Equal ZZ (f' m n') (f' (mul c m) n)) ->
  ----------------------
  Equal (Twiddles n) (halfTwiddles {n} (MkTwiddles (plus n n) f  p1  p2  p3  p4))
                     (                  MkTwiddles n          f' p1' p2' p3' p4') ->
  Equal (Nat -> Nat -> ZZ) f' (doubleM f)
pat n, f, p1, p2, p3, p4,
    p1' : Equal ZZ ((doubleM f) 0 (S n)) (Pos 1),
    p2' : Equal ZZ ((doubleM f) (S n) (S n)) (Pos 1),
    p3' : ((k, m : Nat) -> Equal ZZ (multZ ((doubleM f) k (S n)) ((doubleM f) m (S n))) ((doubleM f) (plus k m) (S n))),
    p4' : ((m, c, n' : Nat) -> Equal Nat (S n) (mul c n') ->
          Equal ZZ ((doubleM f) m n') ((doubleM f) (mul c m) (S n))) =>
  lemmaHalfTwiddleDoublesM (S n) (SIsNonZero n) f p1 p2 p3 p4 (doubleM f) p1' p2' p3' p4' (Refl {_} {_})
    = Refl {_} {_}

{-
lemmaTwiddleRowElemScale :
  (k,n : Nat) ->
  NonZero n ->
  ---------------------- Big twiddle factor defs
  (f : Nat -> Nat -> ZZ) ->
  (p1 : Equal ZZ (f 0 (plus n n)) (Pos 1)) ->
  (p2 : Equal ZZ (f (plus n n) (plus n n)) (Pos 1)) ->
  (p3 : (k, m : Nat) -> Equal ZZ (multZ (f k (plus n n)) (f m (plus n n))) (f (plus k m) (plus n n))) ->
  (p4 : (m, c, n' : Nat) -> Equal Nat (plus n n) (mul c n') ->
        Equal ZZ (f m n') (f (mul c m) (plus n n))) ->
  ----------------------
  (halfTw : Twiddles n) ->
  Equal (Twiddles n) (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4))
                     halfTw ->
  (m : Fin n) ->
  Equal ZZ
    (at {ZZ} {n} m (twiddleRow k           n         n  (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4))))
    (at {ZZ} {n} m (twiddleRow (plus k k)  n (plus n n) (                  MkTwiddles (plus n n) f p1 p2 p3 p4)))

pat k, n, nz, f, p1, p2, p3, p4, m, f', p1', p2', p3', p4', prfTw =>
  lemmaTwiddleRowElemScale k n nz f p1 p2 p3 p4 (MkTwiddles n f' p1' p2' p3' p4') prfTw m

    = let hHalf : Equal ZZ (f (mul (plus k k) (finToNat {n} m)) (plus n n))
                           (at {ZZ} {n} m (twiddleRow (plus k k) n (plus n n) (MkTwiddles (plus n n) f p1 p2 p3 p4)))
                = eqSym {_} {_} {_} (lemmaTwiddleHalfRowElem n (plus k k) m f p1 p2 p3 p4)
          hFull : Equal ZZ (at {ZZ} {n} m (twiddleRow k n n (MkTwiddles n f' p1' p2' p3' p4')))
                           (f' (mul k (finToNat {n} m)) n)
                = lemmaTwiddleRowElem n k m f' p1' p2' p3' p4'
          hFs = lemmaHalfTwiddleDoublesM n nz f p1 p2 p3 p4 f' p1' p2' p3' p4' prfTw
          hFull2 = eqInd2 {_} {_} {_} {eqSym {_} {_} {_} prfTw}
                     {\h=> Equal ZZ (at {ZZ} {n} m (twiddleRow k n n h))
                                    (f' (mul k (finToNat {n} m)) n)}
                     hFull
          hFull3 = eqInd2 {_} {f'} {doubleM f} {hFs}
                     {\h : (Nat -> Nat -> ZZ) =>
                           Equal ZZ (at {ZZ} {n} m (twiddleRow k n n (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4))))
                                    (h (mul k (finToNat {n} m)) n)}
                     hFull2
          {-
          p4' = eqInd2 {_} {_} {_} {eqSym {_} {_} {_} (mulDistributesOverPlusLeft k k (finToNat {n} m))}
                  {\h => Equal ZZ (f') }
                  (p4 (mul k (finToNat {n} m)) 2 n (Refl {_} {_}))
          -}
      in _

{-
    = let h1 = p4 0 2 (S n) (eqInd2 {_} {_} {_} {plusZeroRightNeutral (S n)}
                               {\h => Equal Nat (plus (S n) h) (plus (S n) (plus (S n) 0))}
                               (Refl {_} {_}))
          h2 = eqInd2 {_} {_} {_} {eqSym {_} {_} {_} (mulZeroRightZero k)}
                 {\h => Equal ZZ (f (plus h h) (S n))
                                 (f 0 (plus (S n) (S n)))}
                 h1
          h3 = eqInd2 {_} {_} {_} {eqSym {_} {_} {_} (mulZeroRightZero (plus k k))}
                 {\h => Equal ZZ (f (plus (mul k 0) (mul k 0)) (S n))
                                 (f h (plus (S n) (S n)))}
                 h2
      in h3
-}
{-
hHalf:_0 (Equal ZZ (at {ZZ} {n[6]} m[0] (map n[6] {(Fin n[6])} {ZZ} \i :_0 (Fin n[6]) => (f[6] (mul k[8] (finToNat {n[7]} i[0])) (plus n[7] n[7])) (indices n[6]))) (f[5] (mul k[7] (finToNat {n[6]} m[0])) (plus n[6] n[6])))
hFull:_0 (Equal ZZ (at {ZZ} {n[7]} m[1] (map n[7] {(Fin n[7])} {ZZ} \i :_0 (Fin n[7]) => (f[7] (mul (plus k[9] (plus k[9] 0)) (finToNat {n[8]} i[0])) (plus n[8] n[8])) (indices n[7]))) (f[6] (mul (plus k[8] (plus k[8] 0)) (finToNat {n[7]} m[1])) (plus n[7] n[7])))
--------------------------------
         (Equal ZZ (at {ZZ} {n[8]} m[2] (twiddleRow k[9] n[8] n[8] (halfTwiddles {n[8]} (MkTwiddles (plus n[8] n[8]) f[7] p1[6] p2[5] p3[4] p4[3])))) (at {ZZ} {n[8]} m[2] (map n[8] {(Fin n[8])} {ZZ} \i :_0 (Fin n[8]) => (f[8] (mul (plus k[10] k[10]) (finToNat {n[9]} i[0])) (plus n[9] n[9])) (indices n[8]))))

-}
-}

    
lemmaTwiddleRowScale :
  (k,n : Nat) ->
  ---------------------- Twiddle factor defs
  (f : Nat -> Nat -> ZZ) ->
  (p1 : Equal ZZ (f 0 (plus n n)) (Pos 1)) ->
  (p2 : Equal ZZ (f (plus n n) (plus n n)) (Pos 1)) ->
  (p3 : (k, m : Nat) -> Equal ZZ (multZ (f k (plus n n)) (f m (plus n n))) (f (plus k m) (plus n n))) ->
  (p4 : (m, c, n' : Nat) -> Equal Nat (plus n n) (mul c n') ->
        Equal ZZ (f m n') (f (mul c m) (plus n n))) ->
  ----------------------
  Equal (Vect n ZZ)
    (twiddleRow k          n         n  (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)))
    (twiddleRow (plus k k) n (plus n n) (                  MkTwiddles (plus n n) f p1 p2 p3 p4))
{-
pat k, f, p1, p2, p3, p4 =>
  lemmaTwiddleRowScale k Z f p1 p2 p3 p4
    = Refl {_} {_}
pat k, n, f, p1, p2, p3, p4 =>
  lemmaTwiddleRowScale k (S n) f p1 p2 p3 p4
    = let h1 = \i => p4 (finToNat {n} i) 2 (S n) (Refl {_} {_}) --Can do something with map and our joinPrf helper?
      in _

{-
(VCons {ZZ} {n}
  (f (plus (mul k 0) (mul k 0)) (S n))
  (map n {(Fin (S n))} {ZZ} \i : (Fin (S n)) => (f (plus (mul k (finToNat {(S n)} i)) (mul k (finToNat {(S n)} i))) (S n)) (map n {(Fin n)} {(Fin (S n))} (FS n) (indices n))))

(VCons {ZZ} {n}
  (f (mul (plus k k) 0) (S (plus n (S n))))
  (map n {(Fin (S n))} {ZZ} \i : (Fin (S n)) => (f (mul (plus k k) (finToNat {(S n)} i)) (S (plus n (S n)))) (map n {(Fin n)} {(Fin (S n))} (FS n) (indices n))))
-}
-}

lemmaGatherOddElem :
  {n : Nat} -> (k : Fin n) -> (os : Vect n ZZ) ->
  (f : Nat -> Nat -> ZZ) ->
  (p3 : (k, m : Nat) -> Equal ZZ (multZ (f k (plus n n)) (f m (plus n n))) (f (plus k m) (plus n n))) ->
  (i : Fin n) ->
  Equal ZZ (at {ZZ} {n} i (zipWith n {Fin n} {_} {_} (\j => \x => (multZ (f (finToNat {n} k) (plus n n)) (multZ (f (mul (plus (finToNat {n} k) (finToNat {n} k)) (finToNat {n} j)) (plus n n)) x)))
                             (indices n) os))
           (at {ZZ} {n} i (zipWith n {Fin n} {_} {_} (\j => \x => (multZ (f (mul (mul 2 (plus (finToNat {n} k) 1)) (finToNat {n} j))                                               (plus n n)) x))
                             (indices n) os))
pat k, f, p3, i  =>
  lemmaGatherOddElem {Z} k [] f p3 i = Refl {_} {_}
pat k, x, f, p3 =>
  lemmaGatherOddElem {1} k [x] f p3 (FZ 0)
    = let h1 =
      in _
{-
(multZ (f (finToNat {1} k) 2) (multZ (f (mul (plus (finToNat {1} k) (finToNat {1} k)) 0) 2) x))
===
(multZ (f (mul (plus (plus (finToNat {1} k) 1) (plus (plus (finToNat {1} k) 1) 0))          0) 2) x)

mul by zero:
(multZ (f (finToNat {1} k) 2) (multZ (f 0 2) x))
===
(multZ (f 0 2) x)


pat n, k, x, xs, f, p3, i  =>
  lemmaGatherOddElem {S n} k (VCons {_} {_} x xs) f p3 i
    = let h1 = Refl {_} {multZ (f (finToNat {(S n)} k) (S (plus n (S n)))) (multZ (f (mul (plus (finToNat {(S n)} k) (finToNat {(S n)} k)) 0) (S (plus n (S n)))) x)}
          h2 = eqInd2 {_} {_} {_} {multAssociativeZ (f (finToNat {(S n)} k) (S (plus n (S n))))
                                                    (f (mul (plus (finToNat {(S n)} k) (finToNat {(S n)} k)) 0) (S (plus n (S n))))
                                                    x}
                 {\h => Equal ZZ (multZ (f (finToNat {(S n)} k) (S (plus n (S n)))) (multZ (f (mul (plus (finToNat {(S n)} k) (finToNat {(S n)} k)) 0) (S (plus n (S n)))) x))
                                 h
                 } h1
          h3 = eqInd2 {_} {_} {_} {p3 (finToNat {S n} k) (mul (plus (finToNat {(S n)} k) (finToNat {(S n)} k)) 0)}
                 {\h => Equal ZZ (multZ (f (finToNat {(S n)} k) (S (plus n (S n)))) (multZ (f (mul (plus (finToNat {(S n)} k) (finToNat {(S n)} k)) 0) (S (plus n (S n)))) x))
                                 (multZ h x)
                 } h2
      in _
-}
pat n, k, os, f, p3, i =>
  lemmaGatherOddElem {n} k os f p3 i
    = let h1 = eqInd2 {_} {_} {_} {atCommutesZipWithIndices n {_} {_} i
                                     (\j => \x => (multZ (f (finToNat {n} k) (plus n n)) (multZ (f (mul (plus (finToNat {n} k) (finToNat {n} k)) (finToNat {n} j)) (plus n n)) x)))
                                     os}
                 {\h => Equal ZZ (at {ZZ} {n} i (zipWith n {Fin n} {_} {_}
                                                    (\j => \x => (multZ (f (finToNat {n} k) (plus n n)) (multZ (f (mul (plus (finToNat {n} k) (finToNat {n} k)) (finToNat {n} j)) (plus n n)) x)))
                                                    (indices n) os))
                                 h
                 } (Refl {_} {_})
          -- Rearrange mults
          h2 = eqInd2 {_} {_} {_} {multAssociativeZ (f (finToNat {n} k) (plus n n))  }
                 {\h => Equal ZZ (at {ZZ} {n} i (zipWith n {Fin n} {_} {_}
                                                    (\j => \x => (multZ (f (finToNat {n} k) (plus n n)) (multZ (f (mul (plus (finToNat {n} k) (finToNat {n} k)) (finToNat {n} j)) (plus n n)) x)))
                                                    (indices n) os))
                                 h
                 } h1
      in _

{-
(multZ (f (finToNat {n} k) (plus n n)) (multZ (f (mul (plus (finToNat {n} k) (finToNat {n} k)) (finToNat {n} i)) (plus n n)))
       (at {ZZ} {n} i os)))
-}

lemmaPleaseGod :
  {n : Nat} -> (es,os : Vect n ZZ) -> (xs : Vect (plus n n) ZZ) ->
  Equal (Vect 2 (Vect n ZZ)) (deinterleave n {ZZ} xs) [es,os] ->
  ---------------------- Twiddle factor defs
  (f : Nat -> Nat -> ZZ) ->
  (p1 : Equal ZZ (f 0 (plus n n)) (Pos 1)) ->
  (p2 : Equal ZZ (f (plus n n) (plus n n)) (Pos 1)) ->
  (p3 : (k, m : Nat) -> Equal ZZ (multZ (f k (plus n n)) (f m (plus n n))) (f (plus k m) (plus n n))) ->
  (p4 : (m, c, n' : Nat) -> Equal Nat (plus n n) (mul c n') ->
        Equal ZZ (f m n') (f (mul c m) (plus n n))) ->
  ----------------------
  (k : Fin n) ->
  Equal ZZ
    (plusZ (sumZ n (zipWith n {ZZ} {ZZ} {ZZ} multZ (map n {(Fin n)} {ZZ} (\i : (Fin n) => (f (mul (plus (finToNat {n} k) (finToNat {n} k)) (finToNat {n} i)) (plus n n))) (indices n)) es))
           (sumZ n (zipWith n {(Fin n)} {ZZ} {ZZ} (\j : (Fin n) => \x : ZZ => (multZ (f (mul (plus (plus (finToNat {n} k) 1) (plus (plus (finToNat {n} k) 1) 0)) (finToNat {n} j)) (plus n n)) x)) (indices n) os)))
  
    (sumZ (plus n n) (zipWith (plus n n) {(Fin (plus n n))} {ZZ} {ZZ}
      (\j : (Fin (plus n n)) => \x : ZZ => (multZ (f (mul (finToNat {(plus n n)} (finWeakenN' n {n} k)) (finToNat {(plus n n)} j)) (plus n n)) x))
      (indices (plus n n)) xs))

eqDitRecLower : {n : Nat} ->
               --(isPow2 : Pow2 (plus n n)) ->
               (xs : Vect (plus n n) ZZ) ->
               (es : (Vect n ZZ)) ->
               (os : (Vect n ZZ)) ->
               Equal (Vect 2 (Vect n ZZ)) (deinterleave n {ZZ} xs) [es,os] ->
               ---------------------- Twiddle factor defs
               (f : Nat -> Nat -> ZZ) ->
               (p1 : Equal ZZ (f 0 (plus n n)) (Pos 1)) ->
               (p2 : Equal ZZ (f (plus n n) (plus n n)) (Pos 1)) ->
               (p3 : (k, m : Nat) -> Equal ZZ (multZ (f k (plus n n)) (f m (plus n n))) (f (plus k m) (plus n n))) ->
               (p4 : (m, c, n' : Nat) -> Equal Nat (plus n n) (mul c n') ->
                     Equal ZZ (f m n') (f (mul c m) (plus n n))) ->
               ----------------------
               (k : Fin n) ->
               -- ^ For index `k` only
               Equal ZZ
                 (at {ZZ} {n} k
                     (zipWith n {ZZ} {ZZ} {ZZ} plusZ
                       (dft n (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) es)
                       (zipWith n {ZZ} {ZZ} {ZZ} multZ (twiddleRow 1 n (plus n n) (MkTwiddles (plus n n) f p1 p2 p3 p4))
                                                       (dft n (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) os))))
                 (at {ZZ} {plus n n} (finWeakenN' n {n} k)
                     (dft (plus n n) (MkTwiddles (plus n n) f p1 p2 p3 p4) xs))
pat n, xs, es, os, prfInter, f, p1, p2, p3, p4, k =>
  eqDitRecLower {n} xs es os prfInter f p1 p2 p3 p4 k
    = let -- Push the `at` down as far as possible
          h1 = eqInd2 {_} {_} {_} {atCommutesZipWith n {ZZ} {ZZ} {ZZ} k plusZ
                                     (dft n (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) es)
                                     (zipWith n {ZZ} {ZZ} {ZZ} multZ (twiddleRow 1 n (plus n n) (MkTwiddles (plus n n) f p1 p2 p3 p4))
                                                                     (dft n (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) os))
                                  }
                 {\h => Equal ZZ
                          (at {ZZ} {n} k
                              (zipWith n {ZZ} {ZZ} {ZZ} plusZ
                                (dft n (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) es)
                                (zipWith n {ZZ} {ZZ} {ZZ} multZ (twiddleRow 1 n (plus n n) (MkTwiddles (plus n n) f p1 p2 p3 p4))
                                                                (dft n (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) os))))
                          h
                 } (Refl {_} {_})
          h2 = eqInd2 {_} {_} {_} {atCommutesZipWith n {ZZ} {ZZ} {ZZ} k multZ
                                     (twiddleRow 1 n (plus n n) (MkTwiddles (plus n n) f p1 p2 p3 p4))
                                     (dft n (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) os)
                                  }
                 {\h => Equal ZZ
                          (at {ZZ} {n} k
                              (zipWith n {ZZ} {ZZ} {ZZ} plusZ
                                (dft n (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) es)
                                (zipWith n {ZZ} {ZZ} {ZZ} multZ (twiddleRow 1 n (plus n n) (MkTwiddles (plus n n) f p1 p2 p3 p4))
                                                                (dft n (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) os))))
                          (plusZ
                             (at {_} {_} k (dft n (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) es))
                             h
                          )
                 } h1
          -- Reduce the twiddle factor for our index
          h3 = eqInd2 {_} {_} {_} {lemmaTwiddleHalfRowElem n 1 k f p1 p2 p3 p4}
                 {\h => Equal ZZ
                          (at {ZZ} {n} k
                              (zipWith n {ZZ} {ZZ} {ZZ} plusZ
                                (dft n (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) es)
                                (zipWith n {ZZ} {ZZ} {ZZ} multZ (twiddleRow 1 n (plus n n) (MkTwiddles (plus n n) f p1 p2 p3 p4))
                                                                (dft n (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) os))))
                          (plusZ
                             (at {_} {_} k (dft n (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) es))
                             (multZ h
                                    (at {_} {_} k (dft n (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) os))
                             )
                          )
                 } h2
          h4 = eqInd2 {_} {_} {_} {plusZeroRightNeutral (finToNat {n} k)}
                 {\h => Equal ZZ
                          (at {ZZ} {n} k
                              (zipWith n {ZZ} {ZZ} {ZZ} plusZ
                                (dft n (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) es)
                                (zipWith n {ZZ} {ZZ} {ZZ} multZ (twiddleRow 1 n (plus n n) (MkTwiddles (plus n n) f p1 p2 p3 p4))
                                                                (dft n (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) os))))
                          (plusZ
                             (at {_} {_} k (dft n (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) es))
                             (multZ (f h (plus n n))
                                    (at {_} {_} k (dft n (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) os))
                             )
                          )
                 } h3
          -- Reduce dft calls for our index
          h5 = eqInd2 {_} {_} {_} {atCommutesImap n {_} {_} k (\i => \x=> dftK n i (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) es) es}
                 {\h => Equal ZZ
                          (at {ZZ} {n} k
                              (zipWith n {ZZ} {ZZ} {ZZ} plusZ
                                (dft n (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) es)
                                (zipWith n {ZZ} {ZZ} {ZZ} multZ (twiddleRow 1 n (plus n n) (MkTwiddles (plus n n) f p1 p2 p3 p4))
                                                                (dft n (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) os))))
                          (plusZ
                             h
                             (multZ (f (finToNat {n} k) (plus n n))
                                    (at {_} {_} k (dft n (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) os))
                             )
                          )
                 } h4
          h6 = eqInd2 {_} {_} {_} {atCommutesImap n {_} {_} k (\i=> \x=> dftK n i (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) os) os}
                 {\h => Equal ZZ
                          (at {ZZ} {n} k
                              (zipWith n {ZZ} {ZZ} {ZZ} plusZ
                                (dft n (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) es)
                                (zipWith n {ZZ} {ZZ} {ZZ} multZ (twiddleRow 1 n (plus n n) (MkTwiddles (plus n n) f p1 p2 p3 p4))
                                                                (dft n (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) os))))
                          (plusZ
                             (dftK n k (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) es)
                             (multZ (f (finToNat {n} k) (plus n n))
                                    h
                             )
                          )
                 } h5
          -- Rewrite in terms of full twiddle factor rows
          h7 = eqInd2 {_} {_} {_} {lemmaTwiddleRowScale (finToNat {n} k) n f p1 p2 p3 p4}
                 {\h => Equal ZZ
                          (at {ZZ} {n} k
                              (zipWith n {ZZ} {ZZ} {ZZ} plusZ
                                (dft n (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) es)
                                (zipWith n {ZZ} {ZZ} {ZZ} multZ (twiddleRow 1 n (plus n n) (MkTwiddles (plus n n) f p1 p2 p3 p4))
                                                                (dft n (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) os))))
                          (plusZ
                             (sumZ n (zipWith n {_} {_} {_} multZ h es))
                             (multZ (f (finToNat {n} k) (plus n n))
                                    (sumZ n (zipWith n {_} {_} {_} multZ h os))
                             )
                          )
                 } h6
          -- Move twiddle factor const multiplication into sum and dot product
          h8 = eqInd2 {_} {_} {_} {multDistributesOverSumZ n (f (finToNat {n} k) (plus n n))
                                     (zipWith n {_} {_} {_} multZ (twiddleRow (plus (finToNat {n} k) (finToNat {n} k)) n (plus n n) (MkTwiddles (plus n n) f p1 p2 p3 p4)) os)}
                 {\h => Equal ZZ
                          (at {ZZ} {n} k
                              (zipWith n {ZZ} {ZZ} {ZZ} plusZ
                                (dft n (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) es)
                                (zipWith n {ZZ} {ZZ} {ZZ} multZ (twiddleRow 1 n (plus n n) (MkTwiddles (plus n n) f p1 p2 p3 p4))
                                                                (dft n (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) os))))
                          (plusZ
                             (sumZ n (zipWith n {_} {_} {_} multZ (twiddleRow (plus (finToNat {n} k) (finToNat {n} k)) n (plus n n) (MkTwiddles (plus n n) f p1 p2 p3 p4)) es))
                             h
                          )
                 } h7
          h9 = eqInd2 {_} {_} {_} {mapDistributesOverZipWith n _ _ _ _ (multZ (f (finToNat {n} k) (plus n n))) multZ 
                                     (map n {_} {ZZ} (\i => (f (mul (plus (finToNat {n} k) (finToNat {n} k)) (finToNat {n} i)) (plus n n))) (indices n))
                                     os}
                 {\h => Equal ZZ
                          (at {ZZ} {n} k
                              (zipWith n {ZZ} {ZZ} {ZZ} plusZ
                                (dft n (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) es)
                                (zipWith n {ZZ} {ZZ} {ZZ} multZ (twiddleRow 1 n (plus n n) (MkTwiddles (plus n n) f p1 p2 p3 p4))
                                                                (dft n (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) os))))
                          (plusZ
                             (sumZ n (zipWith n {_} {_} {_} multZ (twiddleRow (plus (finToNat {n} k) (finToNat {n} k)) n (plus n n) (MkTwiddles (plus n n) f p1 p2 p3 p4)) es))
                             (sumZ n h)
                          )
                 } h8
          h10 = eqInd2 {_} {_} {_} {mapReducesZipWith n (Fin n) ZZ ZZ ZZ
                                      (\i : Fin n => (f (mul (plus (finToNat {n} k) (finToNat {n} k)) (finToNat {n} i)) (plus n n)))
                                      (\j => \k' => (multZ (f (finToNat {n} k) (plus n n)) (multZ j k')))
                                      (indices n)
                                      os
                                   }
                 {\h => Equal ZZ
                          (at {ZZ} {n} k
                              (zipWith n {ZZ} {ZZ} {ZZ} plusZ
                                (dft n (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) es)
                                (zipWith n {ZZ} {ZZ} {ZZ} multZ (twiddleRow 1 n (plus n n) (MkTwiddles (plus n n) f p1 p2 p3 p4))
                                                                (dft n (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) os))))
                          (plusZ
                             (sumZ n (zipWith n {_} {_} {_} multZ (twiddleRow (plus (finToNat {n} k) (finToNat {n} k)) n (plus n n) (MkTwiddles (plus n n) f p1 p2 p3 p4)) es))
                             (sumZ n h)
                          )
                 } h9
          -- Combine w^k_2N * w^(2km)_2N into w^(k(2m+1))
          h11 = eqInd2 {_} {_} {_} {eqForAllIndices n {ZZ}
                     (zipWith n {Fin n} {_} {_} (\j => \x => (multZ (f (finToNat {n} k) (plus n n)) (multZ (f (mul (plus (finToNat {n} k) (finToNat {n} k)) (finToNat {n} j)) (plus n n)) x))) (indices n) os)
                     (zipWith n {Fin n} {_} {_} (\j => \x => (multZ (f (mul (mul 2 (plus (finToNat {n} k) 1)) (finToNat {n} j))                                               (plus n n)) x))  (indices n) os)
                     (lemmaGatherOddElem {n} k os f p3)}
                 {\h => Equal ZZ
                          (at {ZZ} {n} k
                              (zipWith n {ZZ} {ZZ} {ZZ} plusZ
                                (dft n (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) es)
                                (zipWith n {ZZ} {ZZ} {ZZ} multZ (twiddleRow 1 n (plus n n) (MkTwiddles (plus n n) f p1 p2 p3 p4))
                                                                (dft n (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) os))))
                          (plusZ
                             (sumZ n (zipWith n {_} {_} {_} multZ (twiddleRow (plus (finToNat {n} k) (finToNat {n} k)) n (plus n n) (MkTwiddles (plus n n) f p1 p2 p3 p4)) es))
                             (sumZ n h)
                          )
                 } h10
          

          -- Starting from RHS now
          g1 = Refl {_} {at {ZZ} {plus n n} (finWeakenN' n {n} k) (dft (plus n n) (MkTwiddles (plus n n) f p1 p2 p3 p4) xs)}
          -- Reduce dft calls for our index
          g2 : Equal ZZ (dftK (plus n n) (finWeakenN' n {n} k) (MkTwiddles (plus n n) f p1 p2 p3 p4) xs)
                        (at {ZZ} {plus n n} (finWeakenN' n {n} k) (dft (plus n n) (MkTwiddles (plus n n) f p1 p2 p3 p4) xs))

             = eqInd2 {_} {_} {_} {atCommutesImap (plus n n) {_} {_} (finWeakenN' n {n} k) (\i => \x=> dftK (plus n n) i (MkTwiddles (plus n n) f p1 p2 p3 p4) xs) xs}
                 {\h => Equal ZZ
                          --(dftK (plus n n) (finWeakenN' n {n} k) (MkTwiddles (plus n n) f p1 p2 p3 p4) xs)
                          h
                          (at {ZZ} {plus n n} (finWeakenN' n {n} k) (dft (plus n n) (MkTwiddles (plus n n) f p1 p2 p3 p4) xs))} g1

          g3 = eqInd2 {_} {_} {_} {mapReducesZipWith (plus n n) (Fin (plus n n)) ZZ ZZ ZZ
                                      (\i : Fin (plus n n) => (f (mul (finToNat {plus n n} (finWeakenN' n {n} k)) (finToNat {plus n n} i)) (plus n n)))
                                      multZ
                                      (indices (plus n n))
                                      xs
                                   }
                 {\h => Equal ZZ
                          (sumZ (plus n n) h)
                          (at {ZZ} {plus n n} (finWeakenN' n {n} k) (dft (plus n n) (MkTwiddles (plus n n) f p1 p2 p3 p4) xs))} g2

          -- Think we're all fed up now... so let's tie the hs and gs together
          fuck = eqInd2 {_} {_} {_} {lemmaPleaseGod {n} es os xs prfInter f p1 p2 p3 p4 k}
                   {\h => Equal ZZ
                            (at {ZZ} {n} k
                                (zipWith n {ZZ} {ZZ} {ZZ} plusZ
                                  (dft n (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) es)
                                  (zipWith n {ZZ} {ZZ} {ZZ} multZ (twiddleRow 1 n (plus n n) (MkTwiddles (plus n n) f p1 p2 p3 p4))
                                                                  (dft n (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) os))))
                            h
                   } h11

      in eqTrans {_} {_} {_} {_} fuck g3

eqDitRecUpper : {n : Nat} ->
               --(isPow2 : Pow2 (plus n n)) ->
               (xs : Vect (plus n n) ZZ) ->
               (es : (Vect n ZZ)) ->
               (os : (Vect n ZZ)) ->
               Equal (Vect 2 (Vect n ZZ)) (deinterleave n {ZZ} xs) [es,os] ->
               ---------------------- Twiddle factor defs
               (f : Nat -> Nat -> ZZ) ->
               (p1 : Equal ZZ (f 0 (plus n n)) (Pos 1)) ->
               (p2 : Equal ZZ (f (plus n n) (plus n n)) (Pos 1)) ->
               (p3 : (k, m : Nat) -> Equal ZZ (multZ (f k (plus n n)) (f m (plus n n))) (f (plus k m) (plus n n))) ->
               (p4 : (m, c, n' : Nat) -> Equal Nat (plus n n) (mul c n') ->
                     Equal ZZ (f m n') (f (mul c m) (plus n n))) ->
               ----------------------
               (k : Fin n) ->
               -- ^ For index `k` only
               Equal ZZ
                 (at {ZZ} {n} k
                     (zipWith n {ZZ} {ZZ} {ZZ} subZ
                       (dft n (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) es)
                       (zipWith n {ZZ} {ZZ} {ZZ} multZ (twiddleRow 1 n (plus n n) (MkTwiddles (plus n n) f p1 p2 p3 p4))
                                                       (dft n (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) os))))
                 (at {ZZ} {plus n n} (finShift n {n} k)
                     (dft (plus n n) (MkTwiddles (plus n n) f p1 p2 p3 p4) xs))

eqDit : {n : Nat} -> (tw : Twiddles n) -> (isPow2 : Pow2 n)  ->
        (xs : Vect n ZZ) ->
        Equal (Vect n ZZ) (dft n tw xs) (dit {n} tw isPow2 xs)

eqDitRec : {n : Nat} -> (tw : Twiddles (plus n n)) -> (isPow2 : Pow2 (plus n n))  ->
           (xs : Vect (plus n n) ZZ) ->
           (split : Vect 2 (Vect n ZZ)) ->
           Equal (Vect 2 (Vect n ZZ)) (deinterleave n {ZZ} xs) split ->
           Equal (Vect (plus n n) ZZ) (dft (plus n n) tw xs) (dit {plus n n} tw isPow2 xs)

pat tw, xs =>
  eqDit {1} tw POne xs = eqDitBase tw xs
pat n, tw, prec, xs =>
  eqDit {plus n n} tw (PDouble n prec) xs
    = eqDitRec {n} tw (PDouble n prec) xs (deinterleave n {ZZ} xs) (Refl {_} {_})


pat n, f, p1, p2, p3, p4, prec, xs, es, os, prfSplit =>
  eqDitRec {n} (MkTwiddles (plus n n) f p1 p2 p3 p4) (PDouble n prec) xs [es,os] prfSplit
    = let h1 = Refl {_} {dit' n (MkTwiddles (plus n n) f p1 p2 p3 p4) prec (deinterleave n {_} xs)}

          -- Apply our proof of deinterleved xs
          h2 : Equal (Vect (plus n n) ZZ)
                          (dit' n (MkTwiddles (plus n n) f p1 p2 p3 p4) prec [es,os])
                          (dit' n (MkTwiddles (plus n n) f p1 p2 p3 p4) prec (deinterleave n {_} xs))
             = eqInd2 {_} {_} {_} {prfSplit}
                 {\h => Equal (Vect (plus n n) ZZ)
                          (dit' n (MkTwiddles (plus n n) f p1 p2 p3 p4) prec h)
                          (dit' n (MkTwiddles (plus n n) f p1 p2 p3 p4) prec (deinterleave n {_} xs))
                 } h1

          -- Recurse on our proof for odd and even sub-dfts
          h3 = eqInd2 {_} {_} {_} {eqSym {_} {_} {_} (eqDit {n} (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) prec es)}
                 {\h => Equal (Vect (plus n n) ZZ)
                          (append {ZZ} {n} {n}
                             (zipWith n {ZZ} {ZZ} {ZZ} plusZ
                                 h (zipWith n {ZZ} {ZZ} {ZZ} multZ (twiddleRow 1 n (plus n n) (MkTwiddles (plus n n) f p1 p2 p3 p4))
                                                                   (dit {n} (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) prec os)))
                             (zipWith n {ZZ} {ZZ} {ZZ} subZ
                                 h (zipWith n {ZZ} {ZZ} {ZZ} multZ (twiddleRow 1 n (plus n n) (MkTwiddles (plus n n) f p1 p2 p3 p4))
                                                                   (dit {n} (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) prec os))))
                          (dit' n (MkTwiddles (plus n n) f p1 p2 p3 p4) prec (deinterleave n {_} xs))
                 } h2
          h4 = eqInd2 {_} {_} {_} {eqSym {_} {_} {_} (eqDit {n} (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) prec os)}
                 {\h => Equal (Vect (plus n n) ZZ)
                          (append {ZZ} {n} {n}
                             (zipWith n {ZZ} {ZZ} {ZZ} plusZ
                                 (dft n (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) es)
                                 (zipWith n {ZZ} {ZZ} {ZZ} multZ (twiddleRow 1 n (plus n n) (MkTwiddles (plus n n) f p1 p2 p3 p4)) h))
                             (zipWith n {ZZ} {ZZ} {ZZ} subZ
                                 (dft n (halfTwiddles {n} (MkTwiddles (plus n n) f p1 p2 p3 p4)) es)
                                 (zipWith n {ZZ} {ZZ} {ZZ} multZ (twiddleRow 1 n (plus n n) (MkTwiddles (plus n n) f p1 p2 p3 p4)) h)))
                          (dit' n (MkTwiddles (plus n n) f p1 p2 p3 p4) prec (deinterleave n {_} xs))
                 } h3

          -- Combine proofs of equality for lower and upper halfs
          h5 = eqInd2 {_} {_} {_} {eqForSplit n n {ZZ} _ _ (dft (plus n n) (MkTwiddles (plus n n) f p1 p2 p3 p4) xs)
                                     (eqDitRecLower {n} xs es os prfSplit f p1 p2 p3 p4)
                                     (eqDitRecUpper {n} xs es os prfSplit f p1 p2 p3 p4)
                                  }
                 {\h => Equal (Vect (plus n n) ZZ)
                          h
                          (dit' n (MkTwiddles (plus n n) f p1 p2 p3 p4) prec (deinterleave n {_} xs))
                 } h4
      in h5

-- A heterogeneous vector to hold a collection of signed numbers with different
-- type-level natural number encodings
simple HWords : (w : Nat) -> (n: Nat) -> Vect n ZZ -> Type where
  HNil : {w : Nat} -> HWords w 0 []
  HCons : {w, n : Nat} ->
          {val : ZZ} ->
          {vals : Vect n ZZ} ->
          Signed w val ->
          HWords w n vals ->
          HWords w (S n) (VCons {ZZ} {n} val vals)

{-
TODO Today!

Need proof of at k (zipWidth f (indices n) xs) = at k (map (f k) xs)
for last twiddle factor rewrite

Might also benefit from putting f in twiddle type, and adding a genTwiddle function given a k and m
-}