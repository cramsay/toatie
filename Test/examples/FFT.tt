import Data.Nat
import Data.Nat.Inequality
import Data.Fin
import Data.Signed
import Data.Vect_ -- This version of Vect is a parameter type, so we can have types who depend on its values
import Proofs

import FFT.Twiddles

-- Witness that a `Nat` is a power of two
data Pow2 : Nat -> Type where
  POne : Pow2 1
  PDouble : (n : Nat) -> Pow2 n -> Pow2 (plus n n)

-- Let's describe the plain, mathematical DFT equation to direct our optimised structure's type
-- See first eqn @ https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm#The_radix-2_DIT_case

dftK : (n : Nat) -> {f : Nat -> Nat -> ZZ} -> Twiddles f n -> Fin n -> Vect n ZZ -> ZZ
pat n, f, k, tw, xs =>
  dftK n {f} tw k xs
    = let mults = zipWith n {_} {_} {_} multZ (twiddleRow {f} n tw (finToNat {n} k) n) xs
      in sumZ n mults

dft : (n : Nat) -> {f : Nat -> Nat -> ZZ} -> Twiddles f n -> Vect n ZZ -> Vect n ZZ
pat n, f, tw, xs =>
  dft n {f} tw xs
    = imap n {_} {_}
           (\i => \x => dftK n {f} tw i xs)
           xs

-- Let's see if we can make a non-synthesisable dit description and prove its equivalence

dit : {n : Nat} -> {f : Nat -> Nat -> ZZ} -> Twiddles f n -> Pow2 n -> Vect n ZZ -> Vect n ZZ

-- Helper for split inputs (helps with our proofs a little bit to be able to refer to this by name)
dit' : (n : Nat) -> {f : Nat -> Nat -> ZZ} -> Twiddles f (plus n n) -> Pow2 n -> Vect 2 (Vect n ZZ) -> Vect (plus n n) ZZ
pat n, f, tw, prec, es, os =>
  dit' n {f} tw prec [es, os]
    = let halfTw = halfTwiddles {f} {n} tw
          -- Recurse on evens
          es' = dit {n} {f} halfTw prec es
          -- Recurse on odds
          os' = dit {n} {f} halfTw prec os
          -- Get odds, multipied by twiddles
          tws = twiddleRow {f} (plus n n) tw 1 n
          os'' = zipWith n {_} {_} {_} multZ tws os' -- ^ For our circuit, we should use
                                                     -- our signed constant nat mult fn but
                                                     -- subtract when or twiddle's negative
          -- Append evens + odds and evens - odds
          outEs = zipWith n {_} {_} {_} plusZ es' os''
          outOs = zipWith n {_} {_} {_} subZ  es' os''
          outs = append {_} {_} {_} outEs outOs
      in outs

pat f, tw, xs =>
  dit {1} {f} tw POne xs = xs
pat n, f, tw, prec, xs =>
  dit {plus n n} {f} tw (PDouble n prec) xs
    = dit' n {f} tw prec (deinterleave n {_} xs)

