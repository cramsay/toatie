-- An example of bounded natural numbers using proofs with the Leibniz equality
--
-- We work towards a bounded natural number (BNat) whose upper limit is encoded in its type.
-- (Similar to `Fin`)
--
-- Addition of two BNats requires a proof that (S n) + m === n + (S m)

import Data.Nat
import Proofs

-- Bounded Nats
data BNat : Nat -> Type where
    BZ : {r : Nat} -> BNat r
    BS : {r : Nat} -> BNat r -> BNat (S r)

-- Conversion from Nat to minimal BNat
natToBNat : (x : Nat) -> BNat x
natToBNat Z = BZ {Z}
pat n =>
  natToBNat (S n) = BS {_} (natToBNat n)

-- Additions of two BNats, preserving their bounds.
-- This relies on our proof of plusSComm
plusB : {r1 : Nat} -> {r2 : Nat} ->
        BNat r1    -> BNat r2 ->
        BNat (plus r1 r2)

pat r1, r2 =>
  plusB {r1} {r2} (BZ {_}) (BZ {_}) = BZ {_}

pat r1, r2, x, y =>
  plusB {S r1} {r2} (BS {_} x) y = BS {_} (plusB {_} {_} x y)

pat r1, r2, y =>
  plusB {r1} {S r2} (BZ {r1}) (BS {r2} y)
    = let rec = BS {_} (plusB {_} {_} (BZ {_}) y)
      in eqInd2 {_} {_} {_} {plusSuccRightSucc r1 r2} {\h => BNat h} rec

-- Examples at REPL:
-- > plusB {3} {2} (BS {2} (BZ {2})) (natToBNat 2)