-- An example of our staging constucts with specialised power functions.
--
-- We work up to two versions of a power function where all of the unrolling is
-- performed at "compile"-time, but leaving the application with the base until
-- run-time.

import Data.Nat

power : Nat -> < Nat > -> < Nat >
pat m : < Nat > =>
  power Z m = [| S Z |]
pat n : Nat, m : < Nat > =>
  power (S n) m = [| mul (~m) (~(power n m)) |]

power' : Nat -> < Nat -> Nat >
power' Z = [| \ x:Nat => S Z |]
pat n : Nat =>
  power' (S n) = [| \x => mul x (~(power' n) x) |]

-- Quirk in type checking where we error on a lambda if the
-- arg is unused and we need to infer it's type

-- Examples at REPL:
-- > power' 6
-- > \b : <Nat> => power 3 b