-- An example of our staging constucts with specialised power functions.
--
-- We work up to two versions of a power function where all of the unrolling is
-- performed at "compile"-time, but leaving the application with the base until
-- run-time.

data Nat : Type where
     Z : Nat
     S : Nat -> Nat

plus : Nat -> Nat -> Nat
pat y : Nat =>
   plus Z y = y
pat k : Nat, y : Nat =>
   plus (S k) y = S (plus k y)

mul : Nat -> Nat -> Nat
pat y : Nat =>
   mul Z y = Z
pat k : Nat, y : Nat =>
   mul (S k) y = plus y (mul k y)

power : Nat -> < Nat > -> < Nat >
pat m : < Nat > =>
  power Z m = [| S Z |]
pat n : Nat, m : < Nat > =>
  power (S n) m = [| mul (~m) (~(power n m)) |]

power' : Nat -> < Nat -> Nat >
power' Z = [| \ x:Nat => S Z |]
pat n : Nat =>
  power' (S n) = [| \x => mul x (~(power' n) x) |]

-- Quirk in type checking where we error on a lambda if the
-- arg is unused and we need to infer it's type

-- Examples at REPL:
-- > power' 6
-- > \b : <Nat> => power 3 b