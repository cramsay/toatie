data Nat : Type where
     Z : Nat
     S : Nat -> Nat

plus : Nat -> Nat -> Nat
pat y : Nat =>
   plus Z y = y
pat k : Nat, y : Nat =>
   plus (S k) y = S (plus k y)

data Vect : Nat -> Type -> Type where
     VNil : {a : Type} -> Vect Z a
     VCons : {a : Type} -> {k : Nat} ->
             a -> Vect k a -> Vect (S k) a

test1 : Vect 3 Nat
test1 = VCons {Nat} {2} 3 (
        VCons {Nat} {1} 4 (
        VCons {Nat} {0} 5 (
        VNil  {Nat}
        )))

test2 : Vect 2 Nat
test2 = VCons {Nat} {1} 1 (
        VCons {Nat} {0} 2 (
        VNil  {Nat}
        ))

test3 : Vect 0 Nat
test3 = VNil {Nat}

head : {a : Type} -> {n : Nat} -> Vect (S n) a -> a
pat a : Type, n : Nat, x : a, xs : Vect n a =>
  head {a} {n} (VCons {a} {n} x xs) = x

tail : {a : Type} -> {n : Nat} -> Vect (S n) a -> Vect n a
pat a : Type, n : Nat, x : a, xs : Vect n a =>
  tail {a} {n} (VCons {a} {n} x xs) = xs

append : {a : Type} -> {n : Nat} -> {m : Nat} -> Vect n a -> Vect m a -> Vect (plus n m) a
pat a : Type, m : Nat, ys : Vect m a =>
  append {a} {Z} {m} (VNil {a}) ys = ys
pat a : Type, n : Nat, m : Nat, x : a, xs : Vect n a, ys : Vect m a =>
  append {a} {(S n)} {m} (VCons {a} {n} x xs) ys = VCons {a} {(plus n m)} x (append {a} {n} {m} xs ys)

-- TODO:
--
-- * Finish examples here
-- * Should we use implicit arguments if we can?  == Yes! If all explicit args are synthable, we can use it in a circuit!

unrollMap : (n : Nat) -> {a : Type} -> {b : Type} ->
            (f : < a -> b >) ->
            < Vect n a -> Vect n b >
pat a : Type, b : Type, f : < a->b > =>
  unrollMap Z {a} {b} f = [| \ xs : Vect Z a => VNil {b} |]
pat n : Nat, a : Type, b : Type, f : < a->b > =>
  unrollMap (S n) {a} {b} f = [|
    \xs : Vect (S n) a =>
       let y  = ~f (head {a} {n} xs)
           ys = ~(unrollMap n {a} {b} f) (tail {a} {n} xs)
       in VCons {b} {n} y ys
  |]

--umap : {n : Nat} -> {a : Type} -> {b : Type} ->
--       (f : < a -> b>) ->
--       < Vect n a > -> < Vect n b >
--pat a : Type, b : Type, f : <a->b>, n : Nat =>
--  umap {Z} {a} {b} f ([| VNil {a} |]) = [| VNil {b} |]
--pat a : Type, b : Type, f : <a->b>, n : Nat, x : a, xs : Vect n a =>
--  umap {(S n)} {a} {b} f ([| VCons {a} {n} x xs |]) = [| VCons {b} {n} ((~f) x) (~(umap {n} {a} {b} f [|xs|])) |]
--
--unrollMap3S : <Vect 3 Nat -> Vect 3 Nat>
--unrollMap3S = unrollMap {3} {Nat} {Nat} [| S |]
--
--unrollFoldl : {n : Nat} -> {acc : Type} -> {elem : Type} ->
--              (f : < acc -> elem -> acc >) ->
--              (init : <acc>) ->
--              < Vect n elem -> acc >
--pat acc : Type, elem : Type, f : <acc->elem->acc>, init : <acc> =>
--  unrollFoldl {Z} {acc} {elem} f init = [| \xs : Vect Z elem => ~init |] 
--pat n : Nat, acc : Type, elem : Type, f : <acc->elem->acc>, init : <acc> =>
--  unrollFoldl {(S n)} {acc} {elem} f init = [|
--    \xs : Vect (S n) elem =>
--      let init' = ~f ~init (head {elem} {n} xs)
--      in ~(unrollFoldl {n} {acc} {elem} f [| init' |]) (tail {elem} {n} xs)
--  |]

--wrong : {x : Nat} -> Nat
--pat {x : Nat} =>
--  wrong {x} = x

-- Examples for REPL:
--
-- Example of append's partial evaluation with implicits
-- > \a:Nat => \b:Nat => \c:Nat => append {Nat} {2} {1} [a,b] [c]
--
-- We can see the the main unrolling easily
-- > unrollMap {3} {Nat} {Nat} [| S |]
--
-- ...but those head and tail functions still aren't evaluated by the escape.
-- We can force this by giving names to each of the elements in the vector
-- > \a:Nat => \b:Nat => \c:Nat => !(unrollMap {3} {Nat} {Nat} [| S |]) [a,b,c]
--
-- That's the core of how we will flatten functions for recursive data types.
--
-- Trying with unrollFoldl:
-- > \init:Nat => \a:Nat => \b:Nat => \c:Nat => !(unrollFoldl {3} {Nat} {Nat} [| plus |] [|init|]) [a,b,c]
