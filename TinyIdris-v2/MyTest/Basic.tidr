data Nat : Type where
     Z : Nat
     S : Nat -> Nat

plus : Nat -> Nat -> Nat
pat y : Nat =>
   plus Z y = y
pat k : Nat, y : Nat =>
   plus (S k) y = S (plus k y)

data Vect : Nat -> Type -> Type where
     Nil : (a : Type) -> Vect Z a
     Cons : (a : Type) -> (k : Nat) ->
            a -> Vect k a -> Vect (S k) a

append : (a : _) -> (n : _) -> (m : _) ->
         Vect n a -> Vect m a -> Vect (plus n m) a
pat a : Type, k : Nat, ys : Vect k a =>
    append a Z k (Nil a) ys = ys
pat a : Type, n : Nat, x : a, xs : Vect n a, k : Nat, ys : Vect k a =>
    append a (S n) k (Cons a n x xs) ys
        = Cons _ _ x (append _ _ _ xs ys)

data Test : Type where
     A : Test
     B : Test
     C : Test
     D : Test

vect1 : Vect (S (S Z)) Test
vect1 = Cons _ _ A (Cons _ _ B (Nil _))

vect2 : Vect (S (S Z)) Test
vect2 = Cons _ _ C (Cons _ _ D (Nil _))

data Bit : Type where
     O : Bit
     I : Bit

xor : Bit -> Bit -> Bit
xor O O = O
xor O I = I
xor I O = I
xor I I = O

or : Bit -> Bit -> Bit
or O O = O
or O I = I
or I O = I
or I I = I

and : Bit -> Bit -> Bit
and O O = O
and O I = O
and I O = O
and I I = I


data Pair : Type -> Type where
     MkP : (a : Type) -> a -> a -> Pair a

dup : Bit -> Pair Bit
pat b : Bit =>
    dup b = MkP Bit b b

fa : Bit -> Bit -> Bit -> Pair Bit
pat a : Bit, b : Bit, cin : Bit =>
    fa a b cin = let axorb : Bit
                           = xor a b
                 in MkP _ (xor axorb cin)
                          (or (and axorb cin) (and a b))

twoTwos : Nat -> Nat
pat x : Nat =>
  twoTwos x = let y : Nat
                    = plus x x in
              let z : Nat
                    = Z        in
              plus y y